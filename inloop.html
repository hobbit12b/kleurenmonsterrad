<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Kleurenmonster Spinner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root { --bg:#f6f7fb; --fg:#111; --panel:#fff; --rand:#111; --soft:#e8f4f5; }
    * { box-sizing: border-box; }
    html, body { height: 100%; -webkit-text-size-adjust: 100%; }
    body {
      margin: 0; padding: 12px;
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg); color: var(--fg);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 900px) {
      body { grid-template-columns: 1fr; }
    }

    .paneel {
      background: var(--panel);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 10px;
    }
    .bordtitel { text-align: center; font-weight: 700; margin-bottom: 6px; }
    .kader {
      background: var(--panel);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 8px;
    }

    .canvas-wrap { width: 100%; }
    #rad     { display:block; width:100%; aspect-ratio: 5 / 4; }
    #monster { display:block; width:100%; aspect-ratio: 5 / 6; }

    .resultaat-rij {
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 10px;
      align-items: center;
      background: var(--soft);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 10px;
      margin-top: 10px;
    }

    .spreekknop {
      width: 100px; height: 100px;
      border-radius: 50%;
      border: 4px solid #000;
      overflow: hidden;
      display: inline-flex; align-items: center; justify-content: center;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 3px 0 #000;
      transition: transform .06s ease;
    }
    .spreekknop:active { transform: translateY(2px); box-shadow: 0 1px 0 #000; }
    .spreekknop img { width: 96%; height: 96%; object-fit: contain; }

    #resultaat { font-size: clamp(14px, 1.8vw, 18px); font-weight: 700; }
    .sub { font-size: clamp(12px, 1.4vw, 14px); opacity: .9; margin-top: 6px; }
    .sub label { user-select: none; }
    #live { position: absolute; left: -9999px; }
  </style>
</head>
<body>

  <!-- Linkerzijde -->
  <div class="paneel">
    <div class="bordtitel">Spinner</div>
    <div class="canvas-wrap">
      <canvas id="rad" aria-label="kleurenspin" title="Tik op het rad om te draaien"></canvas>
    </div>

    <div class="resultaat-rij">
      <button id="spreekBtn" class="spreekknop" aria-label="Spreek kleur">
        <img src="mondknop.png" alt="" />
      </button>
      <div>
        <div id="resultaat">Gekozen kleur: —</div>
        <div class="sub">
          <label>
            <input type="checkbox" id="spreekToggle" />
            Automatisch uitspreken na draaien
          </label>
        </div>
      </div>
      <div id="live" role="status" aria-live="polite"></div>
    </div>
  </div>

  <!-- Rechterzijde -->
  <div class="paneel">
    <div class="bordtitel">Kleurenmonster</div>
    <div class="kader">
      <canvas id="monster" aria-label="kleurenmonster"></canvas>
    </div>
  </div>

<script>
/* ---------------- hulpmiddelen ---------------- */
function sizeCanvasToCss(canvas) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.round(rect.width * dpr));
  const h = Math.max(1, Math.round(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { ctx, cssW: rect.width, cssH: rect.height };
}
function supportMode(ctx, mode) {
  const prev = ctx.globalCompositeOperation;
  ctx.globalCompositeOperation = mode;
  const ok = (ctx.globalCompositeOperation === mode);
  ctx.globalCompositeOperation = prev;
  return ok;
}

/* ---------------- spraak en iPad fixes ---------------- */
const SPEECH_RATE = 0.88;       // trager, prettiger voor jonge kinderen
const SPEECH_PITCH = 1.0;
const SPEECH_VOLUME = 1.0;

let nlVoice = null;
const isAppleMobile =
  /iPad|iPhone|iPod/.test(navigator.userAgent)
  || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

let audioCtx = null;
let ttsPrimed = false;
let iOSResumeTimer = null;

function unlockAudio() {
  try {
    if (audioCtx) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return;
    audioCtx = new Ctx();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    g.gain.value = 0.0001; o.start(); setTimeout(()=>o.stop(), 30);
  } catch {}
}
function waitForVoices(timeoutMs = 1500) {
  return new Promise(resolve => {
    const start = performance.now();
    const check = () => {
      const got = speechSynthesis.getVoices();
      if (got && got.length) return resolve(got);
      if (performance.now() - start > timeoutMs) return resolve(got || []);
      setTimeout(check, 50);
    }; check();
  });
}
function pickVoicesSync() {
  try {
    const voices = speechSynthesis.getVoices() || [];
    nlVoice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('nl')) || null;
  } catch { nlVoice = null; }
}
async function ensureVoice() {
  if (!('speechSynthesis' in window)) return;
  pickVoicesSync();
  if (!nlVoice) { await waitForVoices(); pickVoicesSync(); }
}
function startIOSResumeWatchdog() {
  if (!isAppleMobile) return;
  if (iOSResumeTimer) return;
  iOSResumeTimer = setInterval(() => {
    try { if (speechSynthesis.speaking && speechSynthesis.paused) speechSynthesis.resume(); } catch {}
  }, 200);
}
function stopIOSResumeWatchdog() { if (iOSResumeTimer) { clearInterval(iOSResumeTimer); iOSResumeTimer = null; } }
function primeTTS() {
  if (ttsPrimed || !('speechSynthesis' in window)) return;
  try {
    unlockAudio();
    const u = new SpeechSynthesisUtterance(' ');
    u.lang = nlVoice?.lang || 'nl-NL'; u.volume = 0.01; u.rate = 1; u.pitch = 1;
    speechSynthesis.speak(u); ttsPrimed = true;
  } catch {}
}
function spreekEenmaal(text, rate = SPEECH_RATE) {
  if (!('speechSynthesis' in window)) return;
  try {
    startIOSResumeWatchdog();
    if (!isAppleMobile) speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    if (nlVoice) u.voice = nlVoice;
    u.lang = nlVoice?.lang || 'nl-NL'; u.rate = rate; u.pitch = SPEECH_PITCH; u.volume = SPEECH_VOLUME;
    u.onend = () => { stopIOSResumeWatchdog(); };
    u.onerror = () => { stopIOSResumeWatchdog(); };
    speechSynthesis.speak(u);
  } catch {}
}
// Kies een iPad-vriendelijke uitspraak voor "turquoise"
function uitspraakTurquoise() {
  // op iPad werkt spatie+komma om syllabes te forceren
  return isAppleMobile
    ? "toer, kwaa, zuh"    // klinkt als thur-kwáá-zuh in NL
    : "thurkwáazùh";       // desktop stem pakt accenten prima
}

function spreekKleur(naam) {
  if (!naam) return;
  const key = String(naam).trim().toLowerCase();

  if (key === "turquoise" || key === "turquose" || key === "turqoise") {
    // op iPad net iets trager voor duidelijkheid
    spreekEenmaal(uitspraakTurquoise(), isAppleMobile ? 0.82 : 0.90);
    return;
  }

  // alle andere kleuren
  spreekEenmaal(naam, 0.88);  // iets langzamer dan standaard
}


/* ---------------- kleuren, 80 20 weging ---------------- */
const preferredSet = [
  { label: 'Bruin',     hex: '#8B4513' },
  { label: 'Zilver',    hex: '#C0C0C0' },
  { label: 'Goud',      hex: '#D4AF37' },
  { label: 'Beige',     hex: '#F5F5DC' },
  { label: 'Turquoise', hex: '#40E0D0' },
  { label: 'Zalmroze',  hex: '#FFA07A' },
  { label: 'Grijs',     hex: '#808080' }
];
const limitedSet = [
  { label: 'Wit',   hex: '#FFFFFF' },
  { label: 'Zwart', hex: '#000000' },
  { label: 'Blauw', hex: '#0000FF' },
  { label: 'Roze',  hex: '#FFC0CB' },
  { label: 'Paars', hex: '#800080' },
  { label: 'Rood',  hex: '#FF0000' },
  { label: 'Groen', hex: '#008000' },
  { label: 'Geel',  hex: '#FFFF00' }
];

let opties = [...preferredSet, ...limitedSet].map(o => o.label);
const kleurMap = Object.fromEntries([...preferredSet, ...limitedSet].map(o => [o.label, o.hex]));
const metallicKleuren = new Set(['Goud','Zilver']);
function scheidBuren(arr, a, b) {
  const n = arr.length;
  let ia = arr.indexOf(a), ib = arr.indexOf(b);
  if (ia < 0 || ib < 0) return arr.slice();
  const buren = (x,y)=> Math.abs(x-y)===1 || Math.abs(x-y)===n-1;
  if (!buren(ia, ib)) return arr.slice();
  const kopie = arr.slice();
  const [item] = kopie.splice(ib, 1);
  ia = kopie.indexOf(a); const insert = (ia + 2) % kopie.length;
  kopie.splice(insert, 0, item); return kopie;
}
optes = opties; opties = scheidBuren(optes, 'Goud', 'Zilver');

/* ---------------- spinner ---------------- */
const rad = document.getElementById('rad');
const rctx = rad.getContext('2d');
let hoek = 0, bezig = false, laatsteKleur = '';
const laatste2 = []; // kleine geschiedenis

function renderRad() {
  const { ctx, cssW, cssH } = sizeCanvasToCss(rad);

  const minSide = Math.min(cssW, cssH);
  const R = minSide * 0.45;
  const CX = cssW * 0.44;
  const CY = cssH * 0.50;

  ctx.clearRect(0, 0, cssW, cssH);

  const stap = 2 * Math.PI / opties.length;
  const rot = hoek * Math.PI / 180;

  function normBoog(a0, a1){ const tau = Math.PI*2; let s=a0,e=a1; while(e<s) e+=tau; return [s,e]; }

  function tekenMetallicInSegment(naam, a0, a1) {
    if (!metallicKleuren.has(naam)) return;
    const [s, e] = normBoog(a0, a1);
    ctx.save();
    ctx.beginPath(); ctx.moveTo(CX, CY); ctx.arc(CX, CY, R, s, e, false); ctx.closePath(); ctx.clip();

    const overlayGrad = ctx.createLinearGradient(CX, CY - R, CX, CY + R);
    if (naam === 'Goud') {
      overlayGrad.addColorStop(0.00,'rgba(255,250,210,0.90)');
      overlayGrad.addColorStop(0.30,'rgba(255,255,255,0.28)');
      overlayGrad.addColorStop(0.55,'rgba(0,0,0,0.42)');
      overlayGrad.addColorStop(1.00,'rgba(120,90,0,0.40)');
    } else {
      overlayGrad.addColorStop(0.00,'rgba(255,255,255,0.90)');
      overlayGrad.addColorStop(0.50,'rgba(0,0,0,0.42)');
      overlayGrad.addColorStop(1.00,'rgba(235,235,235,0.42)');
    }
    if (supportMode(ctx,'overlay')) {
      ctx.globalCompositeOperation='overlay';
      ctx.fillStyle=overlayGrad; ctx.fillRect(CX-R, CY-R, R*2, R*2);
      ctx.globalCompositeOperation='source-over';
    } else {
      ctx.globalCompositeOperation='multiply';
      ctx.fillStyle=overlayGrad; ctx.fillRect(CX-R, CY-R, R*2, R*2);
      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle='rgba(255,255,255,0.28)'; ctx.fillRect(CX-R, CY-R, R*2, R*2);
      ctx.globalCompositeOperation='source-over';
    }
    ctx.restore();
  }

  for (let i = 0; i < opties.length; i++) {
    const naam = opties[i];
    const [s, e] = normBoog(i * stap + rot, (i + 1) * stap + rot);
    ctx.beginPath(); ctx.moveTo(CX, CY); ctx.arc(CX, CY, R, s, e, false); ctx.closePath();
    ctx.fillStyle = kleurMap[naam] || '#000'; ctx.fill();
    tekenMetallicInSegment(naam, s, e);
    ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.stroke();

    const mid = s + (e - s) / 2;
    ctx.save(); ctx.translate(CX, CY); ctx.rotate(mid);
    ctx.textAlign = 'right'; ctx.fillStyle = '#000';
    ctx.font = `${Math.max(12, R*0.08)}px system-ui, Arial`;
    ctx.fillText(naam, R - 10, 5);
    ctx.restore();
  }

  ctx.lineWidth = 6; ctx.strokeStyle = '#333';
  ctx.beginPath(); ctx.arc(CX, CY, R + 3, 0, Math.PI * 2); ctx.stroke();

  const offset = R * 0.12;
  const tipX = CX + R + offset;
  const tipY = CY;
  const baseX = tipX + offset * 1.8;
  const halfH = offset * 1.2;
  ctx.beginPath(); ctx.moveTo(tipX, tipY); ctx.lineTo(baseX, tipY - halfH); ctx.lineTo(baseX, tipY + halfH);
  ctx.closePath(); ctx.fillStyle = '#222'; ctx.fill();

  ctx.beginPath(); ctx.arc(CX, CY, Math.max(4, R*0.03), 0, Math.PI*2); ctx.fill();
}

function indexOnderPijl() {
  const n = opties.length, stap = 360 / n;
  let a = (-hoek) % 360; if (a < 0) a += 360;
  return Math.floor(a / stap) % n;
}

/* minder herhaling, 80 20 blijft */
function pickGewogen(){
  const pool = Math.random() < 0.8 ? preferredSet : limitedSet;
  let keuze = pool[Math.floor(Math.random() * pool.length)].label;

  if (keuze === laatsteKleur && Math.random() < 0.70) {
    for (let i = 0; i < 6; i++) {
      const k = pool[Math.floor(Math.random()*pool.length)].label;
      if (k !== laatsteKleur) { keuze = k; break; }
    }
  }
  if (laatste2.includes(keuze)) {
    for (let i = 0; i < 6; i++) {
      const altPool = Math.random() < 0.8 ? preferredSet : limitedSet;
      const k = altPool[Math.floor(Math.random()*altPool.length)].label;
      if (!laatste2.includes(k)) { keuze = k; break; }
    }
  }
  return keuze;
}
function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

function draai() {
  if (bezig) return;
  if (isAppleMobile) { unlockAudio(); primeTTS(); }
  bezig = true;

  const doelNaam = pickGewogen();
  const doelIndex = opties.indexOf(doelNaam);
  const n = opties.length; const stapDeg = 360 / n;

  const aDesired = doelIndex * stapDeg + stapDeg / 2;
  let hoekTargetBase = (-aDesired) % 360; if (hoekTargetBase < 0) hoekTargetBase += 360;

  const rondes = 4 + Math.floor(Math.random() * 2);
  const current = hoek; const currentMod = ((current % 360) + 360) % 360;
  const absoluteTarget = current + ((hoekTargetBase - currentMod + 360) % 360) + 360 * rondes;

  const duur = 1800 + Math.random() * 600; const start = performance.now();
  const startHoek = hoek; const delta = absoluteTarget - startHoek;

  function frame(now) {
    const t = Math.min(1, (now - start) / duur);
    const e = easeInOutCubic(t); hoek = startHoek + delta * e; renderRad();
    if (t < 1) requestAnimationFrame(frame);
    else {
      hoek = absoluteTarget % 360; renderRad();
      const gekozen = doelNaam;
      laatsteKleur = gekozen;
      laatste2.push(gekozen);
      if (laatste2.length > 2) laatste2.shift();

      toonResultaat(gekozen);
      kleurMonster(kleurMap[gekozen], false, false, metallicKleuren.has(gekozen) ? gekozen : null);
      if (document.getElementById('spreekToggle').checked) spreekKleur(gekozen);
      bezig = false;
    }
  }
  requestAnimationFrame(frame);
}

function toonResultaat(tekst){
  document.getElementById('resultaat').textContent = `Gekozen kleur: ${tekst}`;
  document.getElementById('live').textContent = `Kleur ${tekst}`;
}

rad.addEventListener('click', draai);

/* ---------------- monster ---------------- */
const mCanvas = document.getElementById('monster');
const m = mCanvas.getContext('2d');
const imgMask  = new Image();  imgMask.src  = "monster-mask.png";
const imgLine  = new Image();  imgLine.src  = "monster-line.png";
const imgPupil = new Image();  imgPupil.src = "monster-pupillen.png";
let assetsGereed = false;

Promise.all([
  new Promise(res => imgMask.onload  = res),
  new Promise(res => imgLine.onload  = res),
  new Promise(res => imgPupil.onload = res)
]).then(() => { assetsGereed = true; tekenMonsterKader(); kleurMonster('#FFFFFF', false, false, null); });

function tekenMonsterKader() {
  const { ctx, cssW, cssH } = sizeCanvasToCss(mCanvas);
  ctx.clearRect(0, 0, cssW, cssH);
  ctx.save(); ctx.lineWidth = 6; ctx.strokeStyle = "#222"; ctx.fillStyle = "#fff";
  ctx.beginPath(); rondeRechthoek(ctx, 12, 12, cssW - 24, cssH - 24, 18); ctx.fill(); ctx.stroke(); ctx.restore();
}
function kleurMonster(vulkleur, lijnenWit, toonPupillen, metallicType) {
  if (!assetsGereed) return;
  const { ctx, cssW, cssH } = sizeCanvasToCss(mCanvas);
  tekenMonsterKader();

  const pad = 24;
  const doelW = cssW - pad * 2;
  const doelH = cssH - pad * 2;
  const ratio = Math.min(doelW / imgMask.width, doelH / imgMask.height);
  const w = Math.max(1, Math.round(imgMask.width * ratio));
  const h = Math.max(1, Math.round(imgMask.height * ratio));
  const x = Math.round((cssW - w) / 2);
  const y = Math.round((cssH - h) / 2);

  ctx.save();
  ctx.fillStyle = vulkleur; ctx.fillRect(x, y, w, h);
  ctx.globalCompositeOperation = "destination-in"; ctx.imageSmoothingEnabled = true; ctx.drawImage(imgMask, x, y, w, h);
  ctx.globalCompositeOperation = "source-over";

  if (!lijnenWit) { ctx.drawImage(imgLine, x, y, w, h); }
  else {
    const off = document.createElement("canvas"); off.width = w; off.height = h; const o = off.getContext("2d");
    o.fillStyle = "#ffffff"; o.fillRect(0, 0, off.width, off.height);
    o.globalCompositeOperation = "destination-in"; o.drawImage(imgLine, 0, 0, off.width, off.height);
    o.globalCompositeOperation = "source-over"; ctx.drawImage(off, x, y);
  }
  if (toonPupillen) ctx.drawImage(imgPupil, x, y, w, h);

  if (metallicType) voegMetaalGlansToeMonster(ctx, metallicType, x, y, w, h);

  ctx.restore();
}
function voegMetaalGlansToeMonster(ctx, type, x, y, w, h) {
  const overlay = document.createElement('canvas'); overlay.width = w; overlay.height = h; const o = overlay.getContext('2d');
  const lg = o.createLinearGradient(0, 0, 0, h);
  if (type === 'Goud') {
    lg.addColorStop(0.00,'rgba(255,250,210,0.95)');
    lg.addColorStop(0.28,'rgba(255,255,255,0.38)');
    lg.addColorStop(0.55,'rgba(0,0,0,0.48)');
    lg.addColorStop(1.00,'rgba(120,90,0,0.48)');
  } else {
    lg.addColorStop(0.00,'rgba(255,255,255,0.95)');
    lg.addColorStop(0.50,'rgba(0,0,0,0.48)');
    lg.addColorStop(1.00,'rgba(235,235,235,0.52)');
  }
  o.fillStyle = lg; o.fillRect(0,0,w,h);
  o.globalCompositeOperation = 'destination-in'; o.drawImage(imgMask, 0, 0, w, h);

  ctx.save();
  if (supportMode(ctx,'overlay')) { ctx.globalCompositeOperation='overlay'; ctx.drawImage(overlay,x,y); ctx.globalCompositeOperation='screen'; ctx.drawImage(overlay,x,y); ctx.globalCompositeOperation='source-over'; }
  else { ctx.globalCompositeOperation='multiply'; ctx.drawImage(overlay,x,y); ctx.globalCompositeOperation='lighter'; ctx.drawImage(overlay,x,y); ctx.globalCompositeOperation='source-over'; }
  ctx.restore();

  const spec = document.createElement('canvas'); spec.width = w; spec.height = h; const s = spec.getContext('2d');
  const rMax = Math.max(w,h);
  const rg = s.createRadialGradient(w*.30, h*.25, 0, w*.30, h*.25, rMax*.60);
  rg.addColorStop(0,'rgba(255,255,255,1.00)'); rg.addColorStop(.25,'rgba(255,255,255,0.85)'); rg.addColorStop(1,'rgba(255,255,255,0.00)');
  s.fillStyle = rg; s.fillRect(0,0,w,h);
  const rg2 = s.createRadialGradient(w*.70, h*.75, 0, w*.70, h*.75, rMax*.35);
  rg2.addColorStop(0,'rgba(255,255,255,0.95)'); rg2.addColorStop(.40,'rgba(255,255,255,0.55)'); rg2.addColorStop(1,'rgba(255,255,255,0.00)');
  s.fillStyle = rg2; s.fillRect(0,0,w,h);
  s.globalCompositeOperation = 'destination-in'; s.drawImage(imgMask, 0, 0, w, h);

  ctx.save(); if (supportMode(ctx,'screen')) { ctx.globalCompositeOperation='screen'; ctx.drawImage(spec,x,y); ctx.globalCompositeOperation='source-over'; } else { ctx.globalAlpha=.9; ctx.drawImage(spec,x,y); ctx.globalAlpha=1; } ctx.restore();
}
function rondeRechthoek(ctx, x, y, w, h, r) {
  ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
}

/* mondknop actie */
document.getElementById('spreekBtn').addEventListener('click', ()=>{
  if (isAppleMobile) { unlockAudio(); primeTTS(); }
  spreekKleur(laatsteKleur || 'Geen kleur gekozen');
});

/* klik op rad om te draaien */
document.getElementById('rad').addEventListener('click', draai);

/* redraw bij grootte en oriëntatie */
function redrawAll() {
  renderRad();
  tekenMonsterKader();
  if (laatsteKleur) {
    kleurMonster(kleurMap[laatsteKleur], false, false, metallicKleuren.has(laatsteKleur) ? laatsteKleur : null);
  } else {
    kleurMonster('#FFFFFF', false, false, null);
  }
}
window.addEventListener('resize', redrawAll);
window.addEventListener('orientationchange', () => setTimeout(redrawAll, 50));

/* init */
renderRad();
tekenMonsterKader();
kleurMonster('#FFFFFF', false, false, null);
</script>
</body>
</html>

