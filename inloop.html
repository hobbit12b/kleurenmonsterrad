<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Kleurenmonster Spinner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#f6f7fb; --fg:#222; --panel:#fff; }
    * { box-sizing: border-box; }
    body {
      display: grid;
      grid-template-columns: 520px 520px;
      gap: 24px;
      justify-content: center;
      align-items: start;
      padding: 20px;
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    .kolom { display: flex; flex-direction: column; align-items: center; }
    h1 { font-size: 20px; margin: 10px 0; }
    canvas { background: var(--panel); border: 4px solid var(--fg); border-radius: 12px; }
    #rad { width: 500px; height: 400px; }
    button {
      margin-top: 12px; padding: 10px 20px; font-size: 16px;
      border: 0; border-radius: 12px; background: var(--fg); color: #fff; cursor: pointer;
    }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #resultaat { margin-top: 10px; font-size: 18px; font-weight: 700; min-height: 1.5em; }
    #live { position: absolute; left: -9999px; }
    .rij { display: flex; gap: 12px; align-items: center; margin-top: 8px; }
    .rij label { font-size: 14px; user-select: none; }
  </style>
</head>
<body>
  <div class="kolom">
    <h1>Spinner</h1>
    <canvas id="rad" width="500" height="400" aria-label="kleurenspin"></canvas>
    <button id="draaiBtn" aria-describedby="resultaat">Draai</button>
    <div id="resultaat"></div>
    <div class="rij">
      <label>
        <input type="checkbox" id="spreekToggle" checked />
        Kleur uitspreken
      </label>
    </div>
    <div id="live" role="status" aria-live="polite"></div>
  </div>

  <div class="kolom">
    <h1>Kleurenmonster</h1>
    <canvas id="monster" width="400" height="600" aria-label="kleurenmonster"></canvas>
  </div>

  <script>
  // ---------- hulpfunctie voor blendmodus ----------
  function supportMode(ctx, mode) {
    const prev = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = mode;
    const ok = (ctx.globalCompositeOperation === mode);
    ctx.globalCompositeOperation = prev;
    return ok;
  }

  // ---------- spraak met NL stem en iPad harde fix ----------
  let nlVoice = null;

  const isAppleMobile =
    /iPad|iPhone|iPod/.test(navigator.userAgent)
    || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  // Als dit true is, spreekt iPad meteen bij de klik de kleur uit
  const spreekDirectOpIPad = true;

  let audioCtx = null;
  let ttsPrimed = false;
  let iOSResumeTimer = null;

  function unlockAudio() {
    try {
      if (audioCtx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      audioCtx = new Ctx();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.connect(g);
      g.connect(audioCtx.destination);
      g.gain.value = 0.0001;
      o.start();
      setTimeout(() => { o.stop(); }, 30);
    } catch {}
  }

  function waitForVoices(timeoutMs = 1500) {
    return new Promise(resolve => {
      const start = performance.now();
      const check = () => {
        const got = speechSynthesis.getVoices();
        if (got && got.length) return resolve(got);
        if (performance.now() - start > timeoutMs) return resolve(got || []);
        setTimeout(check, 50);
      };
      check();
    });
  }

  function pickVoicesSync() {
    try {
      const voices = speechSynthesis.getVoices() || [];
      nlVoice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('nl')) || null;
    } catch { nlVoice = null; }
  }

  async function ensureVoice() {
    if (!('speechSynthesis' in window)) return;
    pickVoicesSync();
    if (!nlVoice) {
      await waitForVoices();
      pickVoicesSync();
    }
  }

  function startIOSResumeWatchdog() {
    if (!isAppleMobile) return;
    if (iOSResumeTimer) return;
    iOSResumeTimer = setInterval(() => {
      try {
        if (speechSynthesis.speaking && speechSynthesis.paused) {
          speechSynthesis.resume();
        }
      } catch {}
    }, 200);
  }

  function stopIOSResumeWatchdog() {
    if (iOSResumeTimer) {
      clearInterval(iOSResumeTimer);
      iOSResumeTimer = null;
    }
  }

  function primeTTS() {
    if (ttsPrimed || !('speechSynthesis' in window)) return;
    try {
      unlockAudio();
      const u = new SpeechSynthesisUtterance(' ');
      u.lang = nlVoice?.lang || 'nl-NL';
      u.volume = 0.01; // fluister
      u.rate = 1;
      u.pitch = 1;
      speechSynthesis.speak(u);
      ttsPrimed = true;
    } catch {}
  }

  function spreekEenmaal(text, rate = 1.0) {
    if (!('speechSynthesis' in window)) return;
    try {
      startIOSResumeWatchdog();
      if (!isAppleMobile) {
        speechSynthesis.cancel();
      }
      const u = new SpeechSynthesisUtterance(text);
      if (nlVoice) u.voice = nlVoice;
      u.lang = nlVoice?.lang || 'nl-NL';
      u.rate = rate;
      u.pitch = 1.0;
      u.volume = 1.0;
      u.onend = () => { stopIOSResumeWatchdog(); };
      u.onerror = () => { stopIOSResumeWatchdog(); };
      speechSynthesis.speak(u);
    } catch {}
  }

  function spreekKleur(naam) {
    const aan = document.getElementById('spreekToggle')?.checked;
    if (!aan || !('speechSynthesis' in window)) return;
    const key = String(naam || '').toLowerCase().trim();
    if (key === 'turquoise') { spreekEenmaal('thurkwáazùh', 0.98); return; }
    spreekEenmaal(naam, 1.0);
  }

  if ('speechSynthesis' in window) {
    speechSynthesis.onvoiceschanged = pickVoicesSync;
    ensureVoice();
    document.addEventListener('pointerdown', () => {
      if (isAppleMobile && !ttsPrimed) {
        unlockAudio();
        primeTTS();
      }
      ensureVoice();
    }, { once: true });
  }

  // ---------- kleuren en labels ----------
  const preferredSet = [
    { label: 'Bruin',     hex: '#8B4513' },
    { label: 'Zilver',    hex: '#C0C0C0' },
    { label: 'Goud',      hex: '#D4AF37' },
    { label: 'Beige',     hex: '#F5F5DC' },
    { label: 'Turquoise', hex: '#40E0D0' },
    { label: 'Zalmroze',  hex: '#FFA07A' },
    { label: 'Grijs',     hex: '#808080' }
  ];
  const limitedSet = [
    { label: 'Wit',   hex: '#FFFFFF' },
    { label: 'Zwart', hex: '#000000' },
    { label: 'Blauw', hex: '#0000FF' },
    { label: 'Roze',  hex: '#FFC0CB' },
    { label: 'Paars', hex: '#800080' },
    { label: 'Rood',  hex: '#FF0000' },
    { label: 'Groen', hex: '#008000' },
    { label: 'Geel',  hex: '#FFFF00' }
  ];

  let opties = [...preferredSet, ...limitedSet].map(o => o.label);
  const kleurMap = Object.fromEntries([...preferredSet, ...limitedSet].map(o => [o.label, o.hex]));
  const metallicKleuren = new Set(['Goud', 'Zilver']);

  // goud en zilver liever geen buren
  function scheidBuren(arr, a, b) {
    const n = arr.length;
    let ia = arr.indexOf(a), ib = arr.indexOf(b);
    if (ia < 0 || ib < 0) return arr.slice();
    const buren = (x, y) => Math.abs(x - y) === 1 || Math.abs(x - y) === n - 1;
    if (!buren(ia, ib)) return arr.slice();
    const kopie = arr.slice();
    const [item] = kopie.splice(ib, 1);
    ia = kopie.indexOf(a);
    const insert = (ia + 2) % kopie.length;
    kopie.splice(insert, 0, item);
    return kopie;
  }
  opties = scheidBuren(opties, 'Goud', 'Zilver');

  const donkereSegmenten = new Set([]);   // segmenttekst donker
  const lijnenWitKleuren = new Set([]);   // monsterlijnen zwart
  const pupilKleuren = new Set([]);       // pupillen uit

  // ---------- spinner ----------
  const rad = document.getElementById('rad');
  const rctx = rad.getContext('2d');
  const CX = 220, CY = 200, R = 190;
  let hoek = 0, bezig = false;

  function normBoog(a0, a1) {
    const tau = Math.PI * 2;
    let s = a0, e = a1;
    while (e < s) e += tau;
    return [s, e];
  }

  // metallic gloed in segment
  function tekenMetallicInSegment(naam, a0, a1) {
    if (!metallicKleuren.has(naam)) return;
    const [s, e] = normBoog(a0, a1);

    rctx.save();
    rctx.beginPath();
    rctx.moveTo(CX, CY);
    rctx.arc(CX, CY, R, s, e, false);
    rctx.closePath();
    rctx.clip();

    const overlayGrad = rctx.createLinearGradient(CX, CY - R, CX, CY + R);
    if (naam === 'Goud') {
      overlayGrad.addColorStop(0.00, 'rgba(255,250,210,0.90)');
      overlayGrad.addColorStop(0.30, 'rgba(255,255,255,0.28)');
      overlayGrad.addColorStop(0.55, 'rgba(0,0,0,0.42)');
      overlayGrad.addColorStop(1.00, 'rgba(120,90,0,0.40)');
    } else {
      overlayGrad.addColorStop(0.00, 'rgba(255,255,255,0.90)');
      overlayGrad.addColorStop(0.50, 'rgba(0,0,0,0.42)');
      overlayGrad.addColorStop(1.00, 'rgba(235,235,235,0.42)');
    }

    if (supportMode(rctx, 'overlay')) {
      rctx.globalCompositeOperation = 'overlay';
      rctx.fillStyle = overlayGrad;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);
      rctx.globalCompositeOperation = 'source-over';
    } else {
      rctx.globalCompositeOperation = 'multiply';
      rctx.fillStyle = overlayGrad;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);
      rctx.globalCompositeOperation = 'lighter';
      rctx.fillStyle = 'rgba(255,255,255,0.28)';
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);
      rctx.globalCompositeOperation = 'source-over';
    }

    // extra glansstrepen
    rctx.save();
    rctx.translate(CX, CY);
    rctx.rotate(-Math.PI / 10);
    rctx.translate(-CX, -CY);
    rctx.globalAlpha = 0.75;
    for (let i = 0; i < 4; i++) {
      const g = rctx.createLinearGradient(CX - R, CY - R + i * R * 0.22, CX + R, CY - R + i * R * 0.22);
      g.addColorStop(0,   'rgba(255,255,255,0)');
      g.addColorStop(0.5, 'rgba(255,255,255,1.0)');
      g.addColorStop(1,   'rgba(255,255,255,0)');
      rctx.fillStyle = g;
      rctx.fillRect(CX - R, CY - R + i * R * 0.22, R * 2, R * 0.10);
    }
    rctx.restore();
    rctx.globalAlpha = 1;

    // highlights sterker
    if (supportMode(rctx, 'screen')) {
      rctx.globalCompositeOperation = 'screen';
      const rg = rctx.createRadialGradient(CX - R * 0.30, CY - R * 0.35, 0, CX - R * 0.30, CY - R * 0.35, R * 0.95);
      rg.addColorStop(0.00, 'rgba(255,255,255,1.00)');
      rg.addColorStop(0.35, 'rgba(255,255,255,0.85)');
      rg.addColorStop(1.00, 'rgba(255,255,255,0.00)');
      rctx.fillStyle = rg;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);

      const rg2 = rctx.createRadialGradient(CX + R * 0.35, CY + R * 0.35, 0, CX + R * 0.35, CY + R * 0.35, R * 0.50);
      rg2.addColorStop(0.00, 'rgba(255,255,255,0.95)');
      rg2.addColorStop(0.40, 'rgba(255,255,255,0.55)');
      rg2.addColorStop(1.00, 'rgba(255,255,255,0.00)');
      rctx.fillStyle = rg2;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);

      rctx.globalCompositeOperation = 'source-over';
    } else {
      rctx.globalAlpha = 0.85;
      const rg = rctx.createRadialGradient(CX - R * 0.30, CY - R * 0.35, 0, CX - R * 0.30, CY - R * 0.35, R * 0.95);
      rg.addColorStop(0.00, 'rgba(255,255,255,1.00)');
      rg.addColorStop(0.35, 'rgba(255,255,255,0.75)');
      rg.addColorStop(1.00, 'rgba(255,255,255,0.00)');
      rctx.fillStyle = rg;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);
      rctx.globalAlpha = 1;
    }

    rctx.restore();
  }

  function tekenSchijven() {
    const stap = 2 * Math.PI / opties.length;
    const rot = hoek * Math.PI / 180;

    for (let i = 0; i < opties.length; i++) {
      const naam = opties[i];
      const [s, e] = normBoog(i * stap + rot, (i + 1) * stap + rot);

      rctx.beginPath();
      rctx.moveTo(CX, CY);
      rctx.arc(CX, CY, R, s, e, false);
      rctx.closePath();
      rctx.fillStyle = kleurMap[naam] || '#000';
      rctx.fill();

      tekenMetallicInSegment(naam, s, e);

      rctx.strokeStyle = '#222';
      rctx.lineWidth = 2;
      rctx.stroke();

      const mid = s + (e - s) / 2;
      const tekstkleur = donkereSegmenten.has(naam) ? '#fff' : '#000';
      rctx.save();
      rctx.translate(CX, CY);
      rctx.rotate(mid);
      rctx.textAlign = 'right';
      rctx.fillStyle = tekstkleur;
      rctx.font = '16px system-ui, Arial';
      rctx.fillText(naam, R - 12, 6);
      rctx.restore();
    }

    rctx.lineWidth = 6;
    rctx.strokeStyle = '#333';
    rctx.beginPath();
    rctx.arc(CX, CY, R + 3, 0, Math.PI * 2);
    rctx.stroke();
  }

  // pijl buiten het rad, rechts, wijst naar links
  function tekenPijl() {
    const offset = 22;
       const tipX = CX + R + offset;
    const tipY = CY;
    const baseX = tipX + 34;
    const halfH = 22;

    rctx.beginPath();
    rctx.moveTo(tipX, tipY);
    rctx.lineTo(baseX, tipY - halfH);
    rctx.lineTo(baseX, tipY + halfH);
    rctx.closePath();
    rctx.fillStyle = '#222';
    rctx.fill();

    rctx.beginPath();
    rctx.arc(CX, CY, 6, 0, Math.PI * 2);
    rctx.fill();
  }

  function renderRad() {
    rctx.clearRect(0, 0, rad.width, rad.height);
    tekenSchijven();
    tekenPijl();
  }

  // ---------- monster ----------
  const mCanvas = document.getElementById('monster');
  const m = mCanvas.getContext('2d');
  const imgMask  = new Image();  imgMask.src  = 'monster-mask.png';
  const imgLine  = new Image();  imgLine.src  = 'monster-line.png';
  const imgPupil = new Image();  imgPupil.src = 'monster-pupillen.png';

  let assetsGereed = false;
  Promise.all([
    new Promise(res => imgMask.onload  = res),
    new Promise(res => imgLine.onload  = res),
    new Promise(res => imgPupil.onload = res)
  ]).then(() => {
    assetsGereed = true;
    tekenMonsterKader();
    kleurMonster('#FFFFFF', false, false, null);
  });

  function tekenMonsterKader() {
    m.clearRect(0, 0, mCanvas.width, mCanvas.height);
    m.save();
    m.lineWidth = 6;
    m.strokeStyle = '#222';
    m.fillStyle = '#fff';
    m.beginPath();
    rondeRechthoek(m, 12, 12, mCanvas.width - 24, mCanvas.height - 24, 18);
    m.fill();
    m.stroke();
    m.restore();
  }

  function kleurMonster(vulkleur, lijnenWit, toonPupillen, metallicType) {
    if (!assetsGereed) return;

    tekenMonsterKader();

    const pad = 24;
    const doelW = mCanvas.width - pad * 2;
    const doelH = mCanvas.height - pad * 2;
    const ratio = Math.min(doelW / imgMask.width, doelH / imgMask.height);
    const w = Math.max(1, Math.round(imgMask.width * ratio));
    const h = Math.max(1, Math.round(imgMask.height * ratio));
    const x = Math.round((mCanvas.width - w) / 2);
    const y = Math.round((mCanvas.height - h) / 2);

    m.save();
    m.fillStyle = vulkleur;
    m.fillRect(x, y, w, h);
    m.globalCompositeOperation = 'destination-in';
    m.imageSmoothingEnabled = true;
    m.drawImage(imgMask, x, y, w, h);
    m.globalCompositeOperation = 'source-over';

    if (metallicType) voegMetaalGlansToeMonster(metallicType, x, y, w, h);

    if (!lijnenWit) {
      m.drawImage(imgLine, x, y, w, h);
    } else {
      const off = document.createElement('canvas');
      off.width = w; off.height = h;
      const o = off.getContext('2d');
      o.fillStyle = '#ffffff';
      o.fillRect(0, 0, off.width, off.height);
      o.globalCompositeOperation = 'destination-in';
      o.drawImage(imgLine, 0, 0, off.width, off.height);
      o.globalCompositeOperation = 'source-over';
      m.drawImage(off, x, y);
    }

    if (toonPupillen) m.drawImage(imgPupil, x, y, w, h);
    m.restore();
  }

  // sterkere glans voor goud en zilver
  function voegMetaalGlansToeMonster(type, x, y, w, h) {
    const overlay = document.createElement('canvas');
    overlay.width = w; overlay.height = h;
    const o = overlay.getContext('2d');
    const lg = o.createLinearGradient(0, 0, 0, h);
    if (type === 'Goud') {
      lg.addColorStop(0.00, 'rgba(255,250,210,0.95)');
      lg.addColorStop(0.28, 'rgba(255,255,255,0.38)');
      lg.addColorStop(0.55, 'rgba(0,0,0,0.48)');
      lg.addColorStop(1.00, 'rgba(120,90,0,0.48)');
    } else {
      lg.addColorStop(0.00, 'rgba(255,255,255,0.95)');
      lg.addColorStop(0.50, 'rgba(0,0,0,0.48)');
      lg.addColorStop(1.00, 'rgba(235,235,235,0.52)');
    }
    o.fillStyle = lg;
    o.fillRect(0, 0, w, h);
    o.globalCompositeOperation = 'destination-in';
    o.drawImage(imgMask, 0, 0, w, h);

    m.save();
    if (supportMode(m, 'overlay')) {
      m.globalCompositeOperation = 'overlay';
      m.drawImage(overlay, x, y);
      m.globalCompositeOperation = 'screen';
      m.drawImage(overlay, x, y);
      m.globalCompositeOperation = 'source-over';
    } else {
      m.globalCompositeOperation = 'multiply';
      m.drawImage(overlay, x, y);
      m.globalCompositeOperation = 'lighter';
      m.drawImage(overlay, x, y);
      m.globalCompositeOperation = 'source-over';
    }
    m.restore();

    const spec = document.createElement('canvas');
    spec.width = w; spec.height = h;
    const s = spec.getContext('2d');
    const rMax = Math.max(w, h);
    const rg = s.createRadialGradient(w * 0.30, h * 0.25, 0, w * 0.30, h * 0.25, rMax * 0.60);
    rg.addColorStop(0.00, 'rgba(255,255,255,1.00)');
    rg.addColorStop(0.25, 'rgba(255,255,255,0.85)');
    rg.addColorStop(1.00, 'rgba(255,255,255,0.00)');
    s.fillStyle = rg;
    s.fillRect(0, 0, w, h);
    const rg2 = s.createRadialGradient(w * 0.70, h * 0.75, 0, w * 0.70, h * 0.75, rMax * 0.35);
    rg2.addColorStop(0.00, 'rgba(255,255,255,0.95)');
    rg2.addColorStop(0.40, 'rgba(255,255,255,0.55)');
    rg2.addColorStop(1.00, 'rgba(255,255,255,0.00)');
    s.fillStyle = rg2;
    s.fillRect(0, 0, w, h);
    s.globalCompositeOperation = 'destination-in';
    s.drawImage(imgMask, 0, 0, w, h);

    m.save();
    if (supportMode(m, 'screen')) {
      m.globalCompositeOperation = 'screen';
      m.drawImage(spec, x, y);
      m.globalCompositeOperation = 'source-over';
    } else {
      m.globalAlpha = 0.9;
      m.drawImage(spec, x, y);
      m.globalAlpha = 1;
    }
    m.restore();
  }

  function rondeRechthoek(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  // ---------- gewogen keuze 80,20 en spin ----------
  function pickGewogen() {
    const r = Math.random();
    const pool = r < 0.8 ? preferredSet : limitedSet;
    const item = pool[Math.floor(Math.random() * pool.length)];
    return item.label;
  }

  function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

  function draai() {
    if (bezig) return;

    // iPad, audio en TTS direct unlocken en zo nodig direct spreken
    if (isAppleMobile) {
      unlockAudio();
      primeTTS();
    }

    // kies doelkleur volgens 80,20 verdeling
    const doelNaam = pickGewogen();

    // iPad spreekt meteen bij start zodat het gegarandeerd hoorbaar is
    if (isAppleMobile && spreekDirectOpIPad) {
      spreekKleur(doelNaam);
    }

    bezig = true;
    document.getElementById('draaiBtn').disabled = true;

    const doelIndex = opties.indexOf(doelNaam);
    const n = opties.length;
    const stapDeg = 360 / n;

    const aDesired = doelIndex * stapDeg + stapDeg / 2;
    let hoekTargetBase = (-aDesired) % 360;
    if (hoekTargetBase < 0) hoekTargetBase += 360;

    const rondes = 4 + Math.floor(Math.random() * 2);
    const current = hoek;
    const currentMod = ((current % 360) + 360) % 360;
    const absoluteTarget = current + ((hoekTargetBase - currentMod + 360) % 360) + 360 * rondes;

    const duur = 1800 + Math.random() * 600;
    const start = performance.now();
    const startHoek = hoek;
    const delta = absoluteTarget - startHoek;

    function frame(now) {
      const t = Math.min(1, (now - start) / duur);
      const e = easeInOutCubic(t);
      hoek = startHoek + delta * e;
      renderRad();
      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        hoek = absoluteTarget % 360;
        renderRad();

        const gekozen = doelNaam;
        const lijnenWit = lijnenWitKleuren.has(gekozen);
        const toonPupillen = pupilKleuren.has(gekozen);
        const metallicType = metallicKleuren.has(gekozen) ? gekozen : null;

        toonResultaat(gekozen);
        kleurMonster(kleurMap[gekozen], lijnenWit, toonPupillen, metallicType);

        // op pc en niet-iOS pas na het landen spreken
        if (!isAppleMobile || !spreekDirectOpIPad) {
          spreekKleur(gekozen);
        }

        bezig = false;
        document.getElementById('draaiBtn').disabled = false;
      }
    }
    requestAnimationFrame(frame);
  }

  function toonResultaat(tekst) {
    document.getElementById('resultaat').textContent = `Gekozen kleur: ${tekst}`;
    document.getElementById('live').textContent = `Kleur ${tekst}`;
  }

  // init
  document.getElementById('draaiBtn').addEventListener('click', draai);
  document.addEventListener('keydown', e => {
    if ((e.key === 'Enter' || e.code === 'Space') && !bezig) draai();
  });
  renderRad();
  </script>
</body>
</html>
