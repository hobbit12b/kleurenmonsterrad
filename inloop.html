<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Kleurenmonster Spinner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#f6f7fb; --fg:#222; --panel:#fff; }
    * { box-sizing: border-box; }
    body {
      display: grid;
      grid-template-columns: 520px 520px;
      gap: 24px;
      justify-content: center;
      align-items: start;
      padding: 20px;
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    .kolom { display: flex; flex-direction: column; align-items: center; }
    h1 { font-size: 20px; margin: 10px 0; }
    canvas { background: var(--panel); border: 4px solid var(--fg); border-radius: 12px; }
    #rad { width: 500px; height: 400px; }
    button {
      margin-top: 12px; padding: 10px 20px; font-size: 16px;
      border: 0; border-radius: 12px; background: var(--fg); color: #fff; cursor: pointer;
    }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #resultaat { margin-top: 10px; font-size: 18px; font-weight: 700; min-height: 1.5em; }
    #live { position: absolute; left: -9999px; }
    .rij { display: flex; gap: 12px; align-items: center; margin-top: 8px; }
    .rij label { font-size: 14px; user-select: none; }
    select, input[type="checkbox"] { padding: 6px 8px; border: 2px solid var(--fg); border-radius: 10px; }
  </style>
</head>
<body>
  <div class="kolom">
    <h1>Spinner</h1>
    <canvas id="rad" width="500" height="400" aria-label="kleurenspin"></canvas>
    <button id="draaiBtn" aria-describedby="resultaat">Draai</button>
    <div id="resultaat"></div>
    <div class="rij">
      <label>
        <input type="checkbox" id="spreekToggle" checked />
        Kleur uitspreken
      </label>
      <label>
        Effect
        <select id="effectSelect">
          <option value="fade">Zachte fade</option>
          <option value="veeg">Verfveeg</option>
        </select>
      </label>
    </div>
    <div id="live" role="status" aria-live="polite"></div>
  </div>

  <div class="kolom">
    <h1>Kleurenmonster</h1>
    <canvas id="monster" width="400" height="600" aria-label="kleurenmonster"></canvas>
  </div>

  <script>
  // ---------------- Config nieuwe set ----------------
  // Voorkeurskleuren 80 procent
  const preferredSet = [
    { label: 'Bruin',      value: '#8B4513' },
    { label: 'Zilver',     value: '#C0C0C0' },
    { label: 'Goud',       value: '#D4AF37' },
    { label: 'Beige',      value: '#F5F5DC' },
    { label: 'Turquoise',  value: '#40E0D0' },
    { label: 'Zalmroze',   value: '#FFA07A' },
    { label: 'Grijs',      value: '#808080' }
  ];

  // Overige kleuren 20 procent
  const limitedSet = [
    { label: 'Wit',   value: '#FFFFFF' },
    { label: 'Zwart', value: '#000000' },
    { label: 'Blauw', value: '#0000FF' },
    { label: 'Roze',  value: '#FFC0CB' },
    { label: 'Paars', value: '#800080' },
    { label: 'Rood',  value: '#FF0000' },
    { label: 'Groen', value: '#008000' },
    { label: 'Geel',  value: '#FFFF00' }
  ];

  // Spinner gebruikt alleen deze vijftien kleuren, minder dan je oude set
  const opties = [...preferredSet, ...limitedSet].map(o => o.label);

  // Kleurnaam naar hex
  const kleurMap = Object.fromEntries(
    [...preferredSet, ...limitedSet].map(o => [o.label, o.value])
  );

  // Segmenten met witte segmenttekst
  const donkereSegmenten = new Set(['Zwart']);
  function lijnenMoetenWit(naam) { return naam === 'Zwart'; }
  function pupillenTonen(naam) { return naam === 'Zwart'; }

  // ---------------- Spraak ----------------
  let nlVoice = null;
  function pickVoices() {
    try {
      const voices = window.speechSynthesis ? speechSynthesis.getVoices() : [];
      nlVoice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('nl')) || null;
    } catch { nlVoice = null; }
  }
  if ('speechSynthesis' in window) {
    pickVoices();
    speechSynthesis.onvoiceschanged = pickVoices;
  }
  function spreekEenmaal(text, rate = 1.0) {
    if (!('speechSynthesis' in window)) return;
    try {
      speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      if (nlVoice) u.voice = nlVoice;
      u.lang = nlVoice?.lang || 'nl-NL';
      u.rate = rate;
      u.pitch = 1.0;
      u.volume = 1.0;
      speechSynthesis.speak(u);
    } catch {}
  }
  function spreekKleur(naam) {
    const aan = document.getElementById('spreekToggle')?.checked;
    if (!aan) return;
    spreekEenmaal(naam, 1.0);
  }

  // ---------------- Spinner tekenen ----------------
  const rad = document.getElementById('rad');
  const rctx = rad.getContext('2d');
  const CX = 220, CY = 200, R = 190; // rad links, pijl rechts
  let hoek = 0, bezig = false;

  function normBoog(a0, a1) {
    const tau = Math.PI * 2;
    let s = a0, e = a1;
    while (e < s) e += tau;
    return [s, e];
  }

  function tekenSchijven() {
    const stap = 2 * Math.PI / opties.length;
    const rot = hoek * Math.PI / 180;

    for (let i = 0; i < opties.length; i++) {
      const naam = opties[i];
      const [s, e] = normBoog(i * stap + rot, (i + 1) * stap + rot);

      rctx.beginPath();
      rctx.moveTo(CX, CY);
      rctx.arc(CX, CY, R, s, e, false);
      rctx.closePath();
      rctx.fillStyle = kleurMap[naam] || '#000';
      rctx.fill();

      rctx.strokeStyle = '#222';
      rctx.lineWidth = 2;
      rctx.stroke();

      const mid = s + (e - s) / 2;
      const tekstkleur = donkereSegmenten.has(naam) ? '#fff' : '#000';
      rctx.save();
      rctx.translate(CX, CY);
      rctx.rotate(mid);
      rctx.textAlign = 'right';
      rctx.fillStyle = tekstkleur;
      rctx.font = '16px system-ui, Arial';
      rctx.fillText(naam, R - 12, 6);
      rctx.restore();
    }

    rctx.lineWidth = 6;
    rctx.strokeStyle = '#333';
    rctx.beginPath();
    rctx.arc(CX, CY, R + 3, 0, Math.PI * 2);
    rctx.stroke();
  }

  function tekenPijl() {
    const offset = 22;
    const tipX = CX + R + offset;
    const tipY = CY;
    const baseX = tipX + 34;
    const halfH = 22;

    rctx.beginPath();
    rctx.moveTo(tipX, tipY);
    rctx.lineTo(baseX, tipY - halfH);
    rctx.lineTo(baseX, tipY + halfH);
    rctx.closePath();
    rctx.fillStyle = '#222';
    rctx.fill();

    rctx.beginPath();
    rctx.arc(CX, CY, 6, 0, Math.PI * 2);
    rctx.fill();
  }

  function renderRad() {
    rctx.clearRect(0, 0, rad.width, rad.height);
    tekenSchijven();
    tekenPijl();
  }

  // ---------------- Monster ----------------
  const mCanvas = document.getElementById('monster');
  const m = mCanvas.getContext('2d');
  const imgMask  = new Image();  imgMask.src  = 'monster-mask.png';
  const imgLine  = new Image();  imgLine.src  = 'monster-line.png';
  const imgPupil = new Image();  imgPupil.src = 'monster-pupillen.png';

  let assetsGereed = false;
  let geom = null; // {x,y,w,h}

  Promise.all([
    new Promise(res => imgMask.onload  = res),
    new Promise(res => imgLine.onload  = res),
    new Promise(res => imgPupil.onload = res)
  ]).then(() => {
    assetsGereed = true;
    berekenGeom();
    tekenMonsterKader();
    // starttoestand: neutraal op eerste optie
    const startNaam = opties[0];
    currentNaam = startNaam;
    currentWit  = lijnenMoetenWit(startNaam);
    currentPup  = pupillenTonen(startNaam);
    tekenMonsterStatisch(currentNaam, currentWit, currentPup);
  });

  function berekenGeom() {
    const pad = 24;
    const doelW = mCanvas.width - pad * 2;
    const doelH = mCanvas.height - pad * 2;
    const ratio = Math.min(doelW / imgMask.width, doelH / imgMask.height);
    const w = Math.max(1, Math.round(imgMask.width * ratio));
    const h = Math.max(1, Math.round(imgMask.height * ratio));
    const x = Math.round((mCanvas.width - w) / 2);
    const y = Math.round((mCanvas.height - h) / 2);
    geom = { x, y, w, h, pad };
  }

  function tekenMonsterKader() {
    m.clearRect(0, 0, mCanvas.width, mCanvas.height);
    m.save();
    m.lineWidth = 6;
    m.strokeStyle = '#222';
    m.fillStyle = '#fff';
    m.beginPath();
    rondeRechthoek(m, 12, 12, mCanvas.width - 24, mCanvas.height - 24, 18);
    m.fill();
    m.stroke();
    m.restore();
  }

  function bouwMonsterLaag(kleurHex, lijnenWit, pupillen) {
    const off = document.createElement('canvas');
    off.width = mCanvas.width;
    off.height = mCanvas.height;
    const c = off.getContext('2d');
    const {x,y,w,h} = geom;

    c.fillStyle = kleurHex;
    c.fillRect(x, y, w, h);
    c.globalCompositeOperation = 'destination-in';
    c.imageSmoothingEnabled = true;
    c.drawImage(imgMask, x, y, w, h);
    c.globalCompositeOperation = 'source-over';

    if (!lijnenWit) {
      c.drawImage(imgLine, x, y, w, h);
    } else {
      const tint = document.createElement('canvas');
      tint.width = w; tint.height = h;
      const tctx = tint.getContext('2d');
      tctx.fillStyle = '#ffffff';
      tctx.fillRect(0, 0, w, h);
      tctx.globalCompositeOperation = 'destination-in';
      tctx.drawImage(imgLine, 0, 0, w, h);
      tctx.globalCompositeOperation = 'source-over';
      c.drawImage(tint, x, y);
    }

    if (pupillen) c.drawImage(imgPupil, x, y, w, h);

    return off;
  }

  function tekenMonsterStatisch(naam, lijnenWit, pupillen) {
    if (!assetsGereed) return;
    tekenMonsterKader();
    const laag = bouwMonsterLaag(kleurMap[naam], lijnenWit, pupillen);
    m.drawImage(laag, 0, 0);
  }

  // animaties
  let currentNaam = opties[0], currentWit = false, currentPup = false;

  function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

  function animFade(vanNaam, vanWit, vanPup, naarNaam, naarWit, naarPup, duur = 700) {
    const start = performance.now();
    const laagA = bouwMonsterLaag(kleurMap[vanNaam], vanWit, vanPup);
    const laagB = bouwMonsterLaag(kleurMap[naarNaam], naarWit, naarPup);

    function frame(now) {
      const t = Math.min(1, (now - start) / duur);
      const e = easeInOutCubic(t);
      tekenMonsterKader();
      m.globalAlpha = 1;
      m.drawImage(laagA, 0, 0);
      m.globalAlpha = e;
      m.drawImage(laagB, 0, 0);
      m.globalAlpha = 1;
      if (t < 1) requestAnimationFrame(frame);
      else {
        currentNaam = naarNaam; currentWit = naarWit; currentPup = naarPup;
      }
    }
    requestAnimationFrame(frame);
  }

  function animVeeg(vanNaam, vanWit, vanPup, naarNaam, naarWit, naarPup, duur = 800) {
    const start = performance.now();
    const laagA = bouwMonsterLaag(kleurMap[vanNaam], vanWit, vanPup);
    const laagB = bouwMonsterLaag(kleurMap[naarNaam], naarWit, naarPup);
    const {x,y,w,h} = geom;
    const feather = 28;

    function frame(now) {
      const t = Math.min(1, (now - start) / duur);
      const e = easeInOutCubic(t);
      const dek = x + w * e;

      const mask = document.createElement('canvas');
      mask.width = mCanvas.width; mask.height = mCanvas.height;
      const mc = mask.getContext('2d');

      mc.fillStyle = '#fff';
      mc.fillRect(x, y, Math.max(0, dek - feather), h);

      const g = mc.createLinearGradient(dek - feather, 0, dek, 0);
      g.addColorStop(0, 'rgba(255,255,255,0)');
      g.addColorStop(1, 'rgba(255,255,255,1)');
      mc.fillStyle = g;
      mc.fillRect(dek - feather, y, feather, h);

      const temp = document.createElement('canvas');
      temp.width = mCanvas.width; temp.height = mCanvas.height;
      const tc = temp.getContext('2d');
      tc.drawImage(laagB, 0, 0);
      tc.globalCompositeOperation = 'destination-in';
      tc.drawImage(mask, 0, 0);
      tc.globalCompositeOperation = 'source-over';

      tekenMonsterKader();
      m.drawImage(laagA, 0, 0);
      m.drawImage(temp, 0, 0);

      if (t < 1) requestAnimationFrame(frame);
      else {
        currentNaam = naarNaam; currentWit = naarWit; currentPup = naarPup;
      }
    }
    requestAnimationFrame(frame);
  }

  // ---------------- Gewogen keuze ----------------
  function pickGewogen() {
    const r = Math.random();
    const pool = r < 0.8 ? preferredSet : limitedSet; // 80 procent versus 20 procent
    const item = pool[Math.floor(Math.random() * pool.length)];
    return item.label;
  }

  // ---------------- Spin met doelhoek ----------------
  function draai() {
    if (bezig) return;
    bezig = true;
    document.getElementById('draaiBtn').disabled = true;

    // Bepaal doelkleur volgens jouw verdeling
    const doelNaam = pickGewogen();
    const doelIndex = opties.indexOf(doelNaam);
    const n = opties.length;
    const stapDeg = 360 / n;

    // We willen dat het midden van het segment onder de pijl eindigt
    const aDesired = doelIndex * stapDeg + stapDeg / 2; // in graden
    // We hebben: (-hoek_eind) mod 360 = aDesired
    // kies hoek_eind als negatieve aDesired, plus hele rondes voor drama
    let hoekTargetBase = (-aDesired) % 360;
    if (hoekTargetBase < 0) hoekTargetBase += 360;

    // Maak een mooie lange draai, vier tot vijf rondes extra
    const rondes = 4 + Math.floor(Math.random() * 2); // 4 of 5
    const current = hoek;
    // Normaliseer naar 0..360 voor delta
    const currentMod = ((current % 360) + 360) % 360;
    let absoluteTarget = current + ((hoekTargetBase - currentMod + 360) % 360) + 360 * rondes;

    // Easing animatie naar absoluteTarget
    const duur = 1800 + Math.random() * 600;
    const start = performance.now();
    const startHoek = hoek;
    const delta = absoluteTarget - startHoek;

    function frame(now) {
      const t = Math.min(1, (now - start) / duur);
      const e = easeInOutCubic(t);
      hoek = startHoek + delta * e;
      renderRad();
      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        hoek = absoluteTarget % 360;
        renderRad();

        // Toon resultaat en wissel monster met gekozen effect
        toonResultaat(doelNaam);
        const nieuwWit = lijnenMoetenWit(doelNaam);
        const nieuwPup = pupillenTonen(doelNaam);
        const effect = document.getElementById('effectSelect').value;

        if (!assetsGereed) {
          tekenMonsterStatisch(doelNaam, nieuwWit, nieuwPup);
        } else {
          if (effect === 'veeg') {
            animVeeg(currentNaam, currentWit, currentPup, doelNaam, nieuwWit, nieuwPup);
          } else {
            animFade(currentNaam, currentWit, currentPup, doelNaam, nieuwWit, nieuwPup);
          }
        }

        spreekKleur(doelNaam);

        // vrijgeven
        bezig = false;
        document.getElementById('draaiBtn').disabled = false;
      }
    }
    requestAnimationFrame(frame);
  }

  function toonResultaat(tekst) {
    document.getElementById('resultaat').textContent = `Gekozen kleur: ${tekst}`;
    document.getElementById('live').textContent = `Kleur ${tekst}`;
  }

  function rondeRechthoek(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  // init
  document.getElementById('draaiBtn').addEventListener('click', draai);
  document.addEventListener('keydown', e => {
    if ((e.key === 'Enter' || e.code === 'Space') && !bezig) draai();
  });
  renderRad();
  </script>
</body>
</html>
