<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Kleurenmonster Spinner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root { --bg:#f6f7fb; --fg:#111; --panel:#fff; --rand:#111; --soft:#e8f4f5; }
    * { box-sizing: border-box; }
    html, body { height: 100%; -webkit-text-size-adjust: 100%; }
    body {
      margin: 0; padding: 12px;
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg); color: var(--fg);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 900px) {
      body { grid-template-columns: 1fr; }
    }

    .paneel {
      background: var(--panel);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 10px;
    }
    .bordtitel { text-align: center; font-weight: 700; margin-bottom: 6px; }
    .kader {
      background: var(--panel);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 8px;
    }

    .canvas-wrap { width: 100%; }
    #rad     { display:block; width:100%; aspect-ratio: 5 / 4; }
    #monster { display:block; width:100%; aspect-ratio: 5 / 6; }

    .resultaat-rij {
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 10px;
      align-items: center;
      background: var(--soft);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 10px;
      margin-top: 10px;
    }

    .spreekknop {
      width: 100px; height: 100px;
      border-radius: 50%;
      border: 4px solid #000;
      overflow: hidden;
      display: inline-flex; align-items: center; justify-content: center;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 3px 0 #000;
      transition: transform .06s ease;
    }
    .spreekknop:active { transform: translateY(2px); box-shadow: 0 1px 0 #000; }
    .spreekknop img { width: 96%; height: 96%; object-fit: contain; }

    #resultaat { font-size: clamp(14px, 1.8vw, 18px); font-weight: 700; }
    .sub { font-size: clamp(12px, 1.4vw, 14px); opacity: .9; margin-top: 6px; }
    .sub label { user-select: none; }
    #live { position: absolute; left: -9999px; }
  </style>
</head>
<body>

  <!-- Linkerzijde -->
  <div class="paneel">
    <div class="bordtitel">Spinner</div>
    <div class="canvas-wrap">
      <canvas id="rad" aria-label="kleurenspin" title="Tik op het rad om te draaien"></canvas>
    </div>

    <div class="resultaat-rij">
      <button id="spreekBtn" class="spreekknop" aria-label="Spreek kleur">
        <img src="mondknop.png" alt="" />
      </button>
      <div>
        <div id="resultaat">Gekozen kleur: —</div>
        <div class="sub">
          <label>
            <input type="checkbox" id="spreekToggle" />
            Automatisch uitspreken na draaien
          </label>
        </div>
      </div>
      <div id="live" role="status" aria-live="polite"></div>
    </div>
  </div>

  <!-- Rechterzijde -->
  <div class="paneel">
    <div class="bordtitel">Kleurenmonster</div>
    <div class="kader">
      <canvas id="monster" aria-label="kleurenmonster"></canvas>
    </div>
  </div>

<script>
/* ---------------- hulpmiddelen ---------------- */
function sizeCanvasToCss(canvas) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.round(rect.width * dpr));
  const h = Math.max(1, Math.round(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
  }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { ctx, cssW: rect.width, cssH: rect.height };
}
function supportMode(ctx, mode) {
  const prev = ctx.globalCompositeOperation;
  ctx.globalCompositeOperation = mode;
  const ok = (ctx.globalCompositeOperation === mode);
  ctx.globalCompositeOperation = prev;
  return ok;
}

/* ---------------- spraak en iPad fixes ---------------- */
const SPEECH_RATE = 0.88;       // trager, prettiger voor jonge kinderen
const SPEECH_PITCH = 1.0;
const SPEECH_VOLUME = 1.0;

let nlVoice = null;
const isAppleMobile =
  /iPad|iPhone|iPod/.test(navigator.userAgent)
  || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

let audioCtx = null;
let ttsPrimed = false;
let iOSResumeTimer = null;

function unlockAudio() {
  try {
    if (audioCtx) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return;
    audioCtx = new Ctx();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    g.gain.value = 0.0001; o.start(); setTimeout(()=>o.stop(), 30);
  } catch {}
}
function waitForVoices(timeoutMs = 1500) {
  return new Promise(resolve => {
    const start = performance.now();
    const check = () => {
      const got = speechSynthesis.getVoices();
      if (got && got.length) return resolve(got);
      if (performance.now() - start > timeoutMs) return resolve(got || []);
      setTimeout(check, 50);
    }; check();
  });
}
function pickVoicesSync() {
  try {
    const voices = speechSynthesis.getVoices() || [];
    nlVoice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('nl')) || null;
  } catch { nlVoice = null; }
}
async function ensureVoice() {
  if (!('speechSynthesis' in window)) return;
  pickVoicesSync();
  if (!nlVoice) { await waitForVoices(); pickVoicesSync(); }
}
function startIOSResumeWatchdog() {
  if (!isAppleMobile) return;
  if (iOSResumeTimer) return;
  iOSResumeTimer = setInterval(() => {
    try { if (speechSynthesis.speaking && speechSynthesis.paused) speechSynthesis.resume(); } catch {}
  }, 200);
}
function stopIOSResumeWatchdog() { if (iOSResumeTimer) { clearInterval(iOSResumeTimer); iOSResumeTimer = null; } }
function primeTTS() {
  if (ttsPrimed || !('speechSynthesis' in window)) return;
  try {
    unlockAudio();
    const u = new SpeechSynthesisUtterance(' ');
    u.lang = nlVoice?.lang || 'nl-NL'; u.volume = 0.01; u.rate = 1; u.pitch = 1;
    speechSynthesis.speak(u); ttsPrimed = true;
  } catch {}
}
function spreekEenmaal(text, rate = SPEECH_RATE) {
  if (!('speechSynthesis' in window)) return;
  try {
    startIOSResumeWatchdog();
    if (!isAppleMobile) speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    if (nlVoice) u.voice = nlVoice;
    u.lang = nlVoice?.lang || 'nl-NL'; u.rate = rate; u.pitch = SPEECH_PITCH; u.volume = SPEECH_VOLUME;
    u.onend = () => { stopIOSResumeWatchdog(); };
    u.onerror = () => { stopIOSResumeWatchdog(); };
    speechSynthesis.speak(u);
  } catch {}
}
function spreekKleur(naam) {
  if (!naam) return;
  const key = String(naam).trim().toLowerCase();
  if (['turquoise','turquose','turqoise'].includes(key)) { spreekEenmaal('thurkwáazùh', 0.90); return; }
  spreekEenmaal(naam, SPEECH_RATE);
}
if ('speechSynthesis' in window) {
  speechSynthesis.onvoiceschanged = pickVoicesSync;
  ensureVoice();
  document.addEventListener('pointerdown', () => {
    if (isAppleMobile && !ttsPrimed) { unlockAudio(); primeTTS(); }
    ensureVoice();
  }, { once: true });
}

/* ---------------- kleuren, 80 20 weging ---------------- */
const preferredSet = [
  { label: 'Bruin',     hex: '#8B4513' },
  { label: 'Zilver',    hex: '#C0C0C0' },
  { label: 'Goud',      hex: '#D4AF37' },
  { label: 'Beige',     hex: '#F5F5DC' },
  { label: 'Turquoise', hex: '#40E0D0' },
  { label: 'Zalmroze',  hex: '#FFA07A' },
  { label: 'Grijs',     hex: '#808080' }
];
const limitedSet = [
  { label: 'Wit',   hex: '#FFFFFF' },
  { label: 'Zwart', hex: '#000000' },
  { label: 'Blauw', hex: '#0000FF' },
  { label: 'Roze',  hex: '#FFC0CB' },
  { label: 'Paars', hex: '#800080' },
  { label: 'Rood',  hex: '#FF0000' },
  { label: 'Groen', hex: '#008000' },
  { label: 'Geel',  hex: '#FFFF00' }
];

let opties = [...preferredSet, ...limitedSet].map(o => o.label);
const kleurMap = Object.fromEntries([...preferredSet, ...limitedSet].map(o => [o.label, o.hex]));
const metallicKleuren = new Set(['Goud','Zilver']);
function scheidBuren(arr, a, b) {
  const n = arr.length;
  let ia = arr.indexOf(a), ib = arr.indexOf(b);
  if (ia < 0 || ib < 0) return arr.slice();
  const buren = (x,y)=> Math.abs(x-y)===1 || Math.abs(x-y)===n-1;
  if (!buren(ia, ib)) return arr.slice();
  const kopie = arr.slice();
  const [item] = kopie.splice(ib, 1);
  ia = kopie.indexOf(a); const insert = (ia + 2) % kopie.length;
  kopie.splice(insert, 0, item); return kopie;
}
optes = opties; opties = scheidBuren(optes, 'Goud', 'Zilver');

/* ---------------- spinner ---------------- */
const rad = document.getElementById('rad');
const rctx = rad.getContext('2d');
let hoek = 0, bezig = false, laatsteKleur = '';
const laatste2 = []; // kleine geschiedenis

function renderRad() {
  const { ctx, cssW, cssH } = sizeCanvasToCss(rad);

  const minSide = Math.min(cssW, cssH);
  const R = minSide * 0.45;
  const CX = cssW * 0.44;
  const CY = cssH * 0.50;

  ctx.clearRect(0, 0, cssW, cssH);

  const stap = 2 * Math.PI / opties.length;
  const rot = hoek * Math.PI / 180;

  function normBoog(a0, a1){ const tau = Math.PI*2; let s=a0,e=a1; while(e<s) e+=tau; return [s,e]; }

  function tekenMetallicInSegment(naam, a0, a1) {
    if (!metallicKleuren.has(naam)) return;
    const [s, e] = normBoog(a0, a1);
    ctx.save();
    ctx.beginPath(); ctx.moveTo(CX, CY); ctx.arc(CX, CY, R, s, e, false); ctx.closePath(); ctx.clip();

    const overlayGrad = ctx.createLinearGradient(CX, CY - R, CX, CY + R);
    if (naam === 'Goud') {
      overlayGrad.addColorStop(0.00,'rgba(255,250,210,0.90)');
      overlayGrad.addColorStop(0.30,'rgba(255,255,255,0.28)');
      overlayGrad.addColorStop(0.55,'rgba(0,0,0,0.42)');
      overlayGrad.addColorStop(1.00,'rgba(120,90,0,0.40)');
    } else {
      o
