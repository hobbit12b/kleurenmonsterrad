<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Kleurenmonster Spinner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root { --bg:#f6f7fb; --fg:#111; --panel:#fff; --rand:#111; --soft:#e8f4f5; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 12px;
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg); color: var(--fg);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      align-items: start;
    }
    /* Eén kolom op small screens, zoals iPad staand */
    @media (max-width: 1080px) {
      body { grid-template-columns: 1fr; }
    }

    .paneel {
      background: var(--panel);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 10px;
    }
    .bordtitel { text-align: center; font-weight: 700; margin-bottom: 6px; }
    .kader {
      background: var(--panel);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 8px;
    }

    /* Canvas containers met responsive maat, canvassen schalen intern mee met DPR */
    .canvas-wrap { width: 100%; }
    #rad      { display:block; width:100%; height:auto; }
    #monster  { display:block; width:100%; height:auto; }

    /* Resultaatvlak onder het rad, zoals jouw voorbeeld */
    .resultaat-rij {
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 10px;
      align-items: center;
      background: var(--soft);
      border: 3px solid var(--rand);
      border-radius: 12px;
      padding: 10px;
      margin-top: 10px;
    }
    @media (max-width: 480px) {
      .resultaat-rij { grid-template-columns: 90px 1fr; }
    }

    /* Mondknop als jouw afbeelding, rond met zwarte rand, transparant buiten de knop */
    .spreekknop {
      width: 100px; height: 100px;
      border-radius: 50%;
      border: 4px solid #000;
      overflow: hidden;
      display: inline-flex; align-items: center; justify-content: center;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 3px 0 #000;
      transition: transform .06s ease;
    }
    .spreekknop:active { transform: translateY(2px); box-shadow: 0 1px 0 #000; }
    .spreekknop img { width: 96%; height: 96%; object-fit: contain; }

    #resultaat { font-size: clamp(14px, 1.8vw, 18px); font-weight: 700; }
    .sub { font-size: clamp(12px, 1.4vw, 14px); opacity: .9; margin-top: 6px; }
    .sub label { user-select: none; }
    #live { position: absolute; left: -9999px; }
  </style>
</head>
<body>

  <!-- Linkerzijde: Spinner en resultaat -->
  <div class="paneel">
    <div class="bordtitel">Spinner</div>
    <div class="canvas-wrap">
      <!-- vaste ontwerpmaat 500×400, we schalen met DPR en CSS -->
      <canvas id="rad" width="500" height="400" aria-label="kleurenspin" title="Tik op het rad om te draaien"></canvas>
    </div>

    <div class="resultaat-rij">
      <!-- Gebruik jouw mondknop als PNG met transparante achtergrond -->
      <button id="spreekBtn" class="spreekknop" aria-label="Spreek kleur">
        <img src="mondknop.png" alt="" />
      </button>

      <div>
        <div id="resultaat">Gekozen kleur: —</div>
        <div class="sub">
          <label>
            <input type="checkbox" id="spreekToggle" />
            Automatisch uitspreken na draaien
          </label>
        </div>
      </div>
      <div id="live" role="status" aria-live="polite"></div>
    </div>
  </div>

  <!-- Rechterzijde: Kleurenmonster -->
  <div class="paneel">
    <div class="bordtitel">Kleurenmonster</div>
    <div class="kader">
      <!-- vaste ontwerpmaat 500×600, we schalen met DPR en CSS -->
      <canvas id="monster" width="500" height="600" aria-label="kleurenmonster"></canvas>
    </div>
  </div>

<script>
/* ---------- device pixel ratio scaling voor scherpe canvassen ---------- */
function fitCanvasToCss(canvas) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.round(rect.width * dpr));
  const h = Math.max(1, Math.round(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
  }
}

/* ---------- spraak en iPad fixes ---------- */
let nlVoice = null;
const isAppleMobile =
  /iPad|iPhone|iPod/.test(navigator.userAgent)
  || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

let audioCtx = null;
let ttsPrimed = false;
let iOSResumeTimer = null;

function unlockAudio() {
  try {
    if (audioCtx) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return;
    audioCtx = new Ctx();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    g.gain.value = 0.0001; o.start(); setTimeout(()=>o.stop(), 30);
  } catch {}
}
function waitForVoices(timeoutMs = 1500) {
  return new Promise(resolve => {
    const start = performance.now();
    const check = () => {
      const got = speechSynthesis.getVoices();
      if (got && got.length) return resolve(got);
      if (performance.now() - start > timeoutMs) return resolve(got || []);
      setTimeout(check, 50);
    }; check();
  });
}
function pickVoicesSync() {
  try {
    const voices = speechSynthesis.getVoices() || [];
    nlVoice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('nl')) || null;
  } catch { nlVoice = null; }
}
async function ensureVoice() {
  if (!('speechSynthesis' in window)) return;
  pickVoicesSync();
  if (!nlVoice) { await waitForVoices(); pickVoicesSync(); }
}
function startIOSResumeWatchdog() {
  if (!isAppleMobile) return;
  if (iOSResumeTimer) return;
  iOSResumeTimer = setInterval(() => {
    try { if (speechSynthesis.speaking && speechSynthesis.paused) speechSynthesis.resume(); } catch {}
  }, 200);
}
function stopIOSResumeWatchdog() { if (iOSResumeTimer) { clearInterval(iOSResumeTimer); iOSResumeTimer = null; } }
function primeTTS() {
  if (ttsPrimed || !('speechSynthesis' in window)) return;
  try {
    unlockAudio();
    const u = new SpeechSynthesisUtterance(' ');
    u.lang = nlVoice?.lang || 'nl-NL'; u.volume = 0.01; u.rate = 1; u.pitch = 1;
    speechSynthesis.speak(u); ttsPrimed = true;
  } catch {}
}
function spreekEenmaal(text, rate = 1.0) {
  if (!('speechSynthesis' in window)) return;
  try {
    startIOSResumeWatchdog();
    if (!isAppleMobile) speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    if (nlVoice) u.voice = nlVoice;
    u.lang = nlVoice?.lang || 'nl-NL'; u.rate = rate; u.pitch = 1.0; u.volume = 1.0;
    u.onend = () => { stopIOSResumeWatchdog(); };
    u.onerror = () => { stopIOSResumeWatchdog(); };
    speechSynthesis.speak(u);
  } catch {}
}
function spreekKleur(naam) {
  if (!naam) return;
  const key = String(naam).trim().toLowerCase();
  if (['turquoise','turquose','turqoise'].includes(key)) { spreekEenmaal('thurkwáazùh', 0.98); return; }
  spreekEenmaal(naam, 1.0);
}
if ('speechSynthesis' in window) {
  speechSynthesis.onvoiceschanged = pickVoicesSync;
  ensureVoice();
  document.addEventListener('pointerdown', () => {
    if (isAppleMobile && !ttsPrimed) { unlockAudio(); primeTTS(); }
    ensureVoice();
  }, { once: true });
}

/* ---------- kleuren, 80 20 weging ---------- */
const preferredSet = [
  { label: 'Bruin',     hex: '#8B4513' },
  { label: 'Zilver',    hex: '#C0C0C0' },
  { label: 'Goud',      hex: '#D4AF37' },
  { label: 'Beige',     hex: '#F5F5DC' },
  { label: 'Turquoise', hex: '#40E0D0' },
  { label: 'Zalmroze',  hex: '#FFA07A' },
  { label: 'Grijs',     hex: '#808080' }
];
const limitedSet = [
  { label: 'Wit',   hex: '#FFFFFF' },
  { label: 'Zwart', hex: '#000000' },
  { label: 'Blauw', hex: '#0000FF' },
  { label: 'Roze',  hex: '#FFC0CB' },
  { label: 'Paars', hex: '#800080' },
  { label: 'Rood',  hex: '#FF0000' },
  { label: 'Groen', hex: '#008000' },
  { label: 'Geel',  hex: '#FFFF00' }
];

let opties = [...preferredSet, ...limitedSet].map(o => o.label);
const kleurMap = Object.fromEntries([...preferredSet, ...limitedSet].map(o => [o.label, o.hex]));
const metallicKleuren = new Set(['Goud','Zilver']);
function scheidBuren(arr, a, b) {
  const n = arr.length;
  let ia = arr.indexOf(a), ib = arr.indexOf(b);
  if (ia < 0 || ib < 0) return arr.slice();
  const buren = (x,y)=> Math.abs(x-y)===1 || Math.abs(x-y)===n-1;
  if (!buren(ia, ib)) return arr.slice();
  const kopie = arr.slice();
  const [item] = kopie.splice(ib, 1);
  ia = kopie.indexOf(a); const insert = (ia + 2) % kopie.length;
  kopie.splice(insert, 0, item); return kopie;
}
optes = opties; opties = scheidBuren(optes, 'Goud', 'Zilver');

/* ---------- spinner tekenen met schaalfactor ---------- */
const rad = document.getElementById('rad');
const rctx = rad.getContext('2d');
let hoek = 0, bezig = false, laatsteKleur = '';

function renderRad() {
  fitCanvasToCss(rad);
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  // ontwerp basis 500×400, we schalen het tekenvlak
  const baseW = 500, baseH = 400;
  const scaleX = (rad.width  / dpr) / baseW;
  const scaleY = (rad.height / dpr) / baseH;
  const k = Math.min(scaleX, scaleY);

  rctx.save();
  rctx.setTransform(dpr * k, 0, 0, dpr * k, 0, 0);
  rctx.clearRect(0, 0, baseW, baseH);

  const CX = 220, CY = 200, R = 190;
  const stap = 2 * Math.PI / opties.length;
  const rot = hoek * Math.PI / 180;

  function normBoog(a0, a1) { const tau = Math.PI*2; let s=a0,e=a1; while(e<s) e+=tau; return [s,e]; }

  function tekenMetallicInSegment(naam, a0, a1) {
    if (!metallicKleuren.has(naam)) return;
    const [s, e] = normBoog(a0, a1);
    rctx.save();
    rctx.beginPath(); rctx.moveTo(CX, CY); rctx.arc(CX, CY, R, s, e, false); rctx.closePath(); rctx.clip();

    const overlayGrad = rctx.createLinearGradient(CX, CY - R, CX, CY + R);
    if (naam === 'Goud') {
      overlayGrad.addColorStop(0.00,'rgba(255,250,210,0.90)');
      overlayGrad.addColorStop(0.30,'rgba(255,255,255,0.28)');
      overlayGrad.addColorStop(0.55,'rgba(0,0,0,0.42)');
      overlayGrad.addColorStop(1.00,'rgba(120,90,0,0.40)');
    } else {
      overlayGrad.addColorStop(0.00,'rgba(255,255,255,0.90)');
      overlayGrad.addColorStop(0.50,'rgba(0,0,0,0.42)');
      overlayGrad.addColorStop(1.00,'rgba(235,235,235,0.42)');
    }
    rctx.globalCompositeOperation='overlay'; rctx.fillStyle=overlayGrad;
    rctx.fillRect(CX-R, CY-R, R*2, R*2);
    rctx.globalCompositeOperation='source-over';

    rctx.restore();
  }

  // schijven
  for (let i=0;i<optes.length;i++){} // defensieve no-op

  for (let i = 0; i < opties.length; i++) {
    const naam = opties[i];
    const [s, e] = normBoog(i * stap + rot, (i + 1) * stap + rot);
    rctx.beginPath(); rctx.moveTo(CX, CY); rctx.arc(CX, CY, R, s, e, false); rctx.closePath();
    rctx.fillStyle = kleurMap[naam] || '#000'; rctx.fill();

    tekenMetallicInSegment(naam, s, e);

    rctx.strokeStyle = '#222'; rctx.lineWidth = 2; rctx.stroke();

    const mid = s + (e - s) / 2;
    rctx.save(); rctx.translate(CX, CY); rctx.rotate(mid);
    rctx.textAlign = 'right'; rctx.fillStyle = '#000';
    rctx.font = '16px system-ui, Arial'; rctx.fillText(naam, R - 12, 6);
    rctx.restore();
  }

  // rand
  rctx.lineWidth = 6; rctx.strokeStyle = '#333';
  rctx.beginPath(); rctx.arc(CX, CY, R + 3, 0, Math.PI * 2); rctx.stroke();

  // pijl rechts
  const offset = 22; const tipX = CX + R + offset; const tipY = CY; const baseX = tipX + 34; const halfH = 22;
  rctx.beginPath(); rctx.moveTo(tipX, tipY); rctx.lineTo(baseX, tipY - halfH); rctx.lineTo(baseX, tipY + halfH);
  rctx.closePath(); rctx.fillStyle = '#222'; rctx.fill();
  rctx.beginPath(); rctx.arc(CX, CY, 6, 0, Math.PI*2); rctx.fill();

  rctx.restore();
}

function pickGewogen(){
  const r = Math.random();
  const pool = r < 0.8 ? preferredSet : limitedSet;
  const item = pool[Math.floor(Math.random() * pool.length)];
  return item.label;
}
function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

function draai() {
  if (bezig) return;
  if (isAppleMobile) { unlockAudio(); primeTTS(); }
  bezig = true;

  const doelNaam = pickGewogen();
  const doelIndex = opties.indexOf(doelNaam);
  const n = opties.length; const stapDeg = 360 / n;

  const aDesired = doelIndex * stapDeg + stapDeg / 2;
  let hoekTargetBase = (-aDesired) % 360; if (hoekTargetBase < 0) hoekTargetBase += 360;

  const rondes = 4 + Math.floor(Math.random() * 2);
  const current = hoek; const currentMod = ((current % 360) + 360) % 360;
  const absoluteTarget = current + ((hoekTargetBase - currentMod + 360) % 360) + 360 * rondes;

  const duur = 1800 + Math.random() * 600; const start = performance.now();
  const startHoek = hoek; const delta = absoluteTarget - startHoek;

  function frame(now) {
    const t = Math.min(1, (now - start) / duur);
    const e = easeInOutCubic(t); hoek = startHoek + delta * e; renderRad();
    if (t < 1) requestAnimationFrame(frame);
    else {
      hoek = absoluteTarget % 360; renderRad();
      const gekozen = doelNaam; laatsteKleur = gekozen;
      toonResultaat(gekozen);
      kleurMonster(kleurMap[gekozen], false, false, metallicKleuren.has(gekozen) ? gekozen : null);
      if (document.getElementById('spreekToggle').checked) spreekKleur(gekozen);
      bezig = false;
    }
  }
  requestAnimationFrame(frame);
}
function toonResultaat(tekst){
  document.getElementById('resultaat').textContent = `Gekozen kleur: ${tekst}`;
  document.getElementById('live').textContent = `Kleur ${tekst}`;
}

/* klik op het rad om te draaien */
rad.addEventListener('click', draai);

/* ---------- monster, exact als eerder, met DPR scaling ---------- */
const mCanvas = document.getElementById('monster');
const m = mCanvas.getContext('2d');
const imgMask  = new Image();  imgMask.src  = "monster-mask.png";
const imgLine  = new Image();  imgLine.src  = "monster-line.png";
const imgPupil = new Image();  imgPupil.src = "monster-pupillen.png";
let assetsGereed = false;

Promise.all([
  new Promise(res => imgMask.onload  = res),
  new Promise(res => imgLine.onload  = res),
  new Promise(res => imgPupil.onload = res)
]).then(() => { assetsGereed = true; tekenMonsterKader(); kleurMonster('#FFFFFF', false, false, null); });

function renderMonsterBackdrop() {
  fitCanvasToCss(mCanvas);
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  m.setTransform(dpr,0,0,dpr,0,0);
}

function tekenMonsterKader() {
  renderMonsterBackdrop();
  m.clearRect(0, 0, mCanvas.width, mCanvas.height);
  m.save(); m.lineWidth = 6; m.strokeStyle = "#222"; m.fillStyle = "#fff";
  m.beginPath(); rondeRechthoek(m, 12, 12, mCanvas.clientWidth - 24, mCanvas.clientHeight - 24, 18); m.fill(); m.stroke(); m.restore();
}
function kleurMonster(vulkleur, lijnenWit, toonPupillen, metallicType) {
  if (!assetsGereed) return;
  renderMonsterBackdrop();
  tekenMonsterKader();

  const pad = 24;
  const doelW = mCanvas.clientWidth - pad * 2;
  const doelH = mCanvas.clientHeight - pad * 2;

  // op basis van originele assetmaat, schaal proportioneel
  const ratio = Math.min(doelW / imgMask.width, doelH / imgMask.height);
  const w = Math.max(1, Math.round(imgMask.width * ratio));
  const h = Math.max(1, Math.round(imgMask.height * ratio));
  const x = Math.round((mCanvas.clientWidth - w) / 2);
  const y = Math.round((mCanvas.clientHeight - h) / 2);

  m.save();
  m.fillStyle = vulkleur; m.fillRect(x, y, w, h);
  m.globalCompositeOperation = "destination-in"; m.imageSmoothingEnabled = true; m.drawImage(imgMask, x, y, w, h);
  m.globalCompositeOperation = "source-over";

  if (!lijnenWit) m.drawImage(imgLine, x, y, w, h);
  else {
    const off = document.createElement("canvas"); off.width = w; off.height = h; const o = off.getContext("2d");
    o.fillStyle = "#ffffff"; o.fillRect(0, 0, off.width, off.height);
    o.globalCompositeOperation = "destination-in"; o.drawImage(imgLine, 0, 0, off.width, off.height);
    o.globalCompositeOperation = "source-over"; m.drawImage(off, x, y);
  }
  if (toonPupillen) m.drawImage(imgPupil, x, y, w, h);

  // extra glans voor goud en zilver
  if (metallicType) voegMetaalGlansToeMonster(metallicType, x, y, w, h);

  m.restore();
}
function voegMetaalGlansToeMonster(type, x, y, w, h) {
  const overlay = document.createElement('canvas'); overlay.width = w; overlay.height = h; const o = overlay.getContext('2d');
  const lg = o.createLinearGradient(0, 0, 0, h);
  if (type === 'Goud') {
    lg.addColorStop(0.00,'rgba(255,250,210,0.95)');
    lg.addColorStop(0.28,'rgba(255,255,255,0.38)');
    lg.addColorStop(0.55,'rgba(0,0,0,0.48)');
    lg.addColorStop(1.00,'rgba(120,90,0,0.48)');
  } else {
    lg.addColorStop(0.00,'rgba(255,255,255,0.95)');
    lg.addColorStop(0.50,'rgba(0,0,0,0.48)');
    lg.addColorStop(1.00,'rgba(235,235,235,0.52)');
  }
  o.fillStyle = lg; o.fillRect(0,0,w,h);
  o.globalCompositeOperation = 'destination-in'; o.drawImage(imgMask, 0, 0, w, h);

  m.save(); m.globalCompositeOperation='overlay'; m.drawImage(overlay,x,y); m.globalCompositeOperation='screen'; m.drawImage(overlay,x,y); m.globalCompositeOperation='source-over'; m.restore();

  const spec = document.createElement('canvas'); spec.width = w; spec.height = h; const s = spec.getContext('2d');
  const rMax = Math.max(w,h);
  const rg = s.createRadialGradient(w*.30, h*.25, 0, w*.30, h*.25, rMax*.60);
  rg.addColorStop(0,'rgba(255,255,255,1.00)'); rg.addColorStop(.25,'rgba(255,255,255,0.85)'); rg.addColorStop(1,'rgba(255,255,255,0.00)');
  s.fillStyle = rg; s.fillRect(0,0,w,h);
  const rg2 = s.createRadialGradient(w*.70, h*.75, 0, w*.70, h*.75, rMax*.35);
  rg2.addColorStop(0,'rgba(255,255,255,0.95)'); rg2.addColorStop(.40,'rgba(255,255,255,0.55)'); rg2.addColorStop(1,'rgba(255,255,255,0.00)');
  s.fillStyle = rg2; s.fillRect(0,0,w,h);
  s.globalCompositeOperation = 'destination-in'; s.drawImage(imgMask, 0, 0, w, h);

  m.save(); m.globalCompositeOperation='screen'; m.drawImage(spec,x,y); m.globalCompositeOperation='source-over'; m.restore();
}
function rondeRechthoek(ctx, x, y, w, h, r) {
  ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
}

/* ---------- mondknop actie ---------- */
document.getElementById('spreekBtn').addEventListener('click', ()=>{
  if (isAppleMobile) { unlockAudio(); primeTTS(); }
  spreekKleur(laatsteKleur || 'Geen kleur gekozen');
});

/* ---------- resize, houdt alles passend ---------- */
function resizeAll() {
  renderRad();
  tekenMonsterKader();
  // kleur opnieuw tekenen in huidige kleur, behoudt state
  if (laatsteKleur) {
    kleurMonster(kleurMap[laatsteKleur], false, false, metallicKleuren.has(laatsteKleur) ? laatsteKleur : null);
  } else {
    kleurMonster('#FFFFFF', false, false, null);
  }
}
window.addEventListener('resize', resizeAll);
window.addEventListener('orientationchange', () => setTimeout(resizeAll, 50));

/* init */
renderRad();
tekenMonsterKader();
kleurMonster('#FFFFFF', false, false, null);
</script>
</body>
</html>
