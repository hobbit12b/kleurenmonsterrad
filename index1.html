<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Kleurenmonster Spinner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#f6f7fb; --fg:#222; --panel:#fff; }
    * { box-sizing: border-box; }
    body {
      display: grid;
      grid-template-columns: 520px 520px;
      gap: 24px;
      justify-content: center;
      align-items: start;
      padding: 20px;
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    .kolom { display: flex; flex-direction: column; align-items: center; }
    h1 { font-size: 20px; margin: 10px 0; }
    canvas { background: var(--panel); border: 4px solid var(--fg); border-radius: 12px; }
    #rad { width: 500px; height: 400px; }
    button {
      margin-top: 12px; padding: 10px 20px; font-size: 16px;
      border: 0; border-radius: 12px; background: var(--fg); color: #fff; cursor: pointer;
    }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #resultaat { margin-top: 10px; font-size: 18px; font-weight: 700; min-height: 1.5em; }
    #live { position: absolute; left: -9999px; }
    .rij { display: flex; gap: 12px; align-items: center; margin-top: 8px; }
    .rij label { font-size: 14px; user-select: none; }
  </style>
</head>
<body>
  <div class="kolom">
    <h1>Spinner</h1>
    <canvas id="rad" width="500" height="400" aria-label="kleurenspin"></canvas>
    <button id="draaiBtn" aria-describedby="resultaat">Draai</button>
    <div id="resultaat"></div>
    <div class="rij">
      <label>
        <input type="checkbox" id="spreekToggle" checked />
        Kleur uitspreken
      </label>
    </div>
    <div id="live" role="status" aria-live="polite"></div>
  </div>

  <div class="kolom">
    <h1>Kleurenmonster</h1>
    <canvas id="monster" width="400" height="600" aria-label="kleurenmonster"></canvas>
  </div>

  <script>
  // hulpfunctie voor blendmodus
  function supportMode(ctx, mode) {
    const prev = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = mode;
    const ok = (ctx.globalCompositeOperation === mode);
    ctx.globalCompositeOperation = prev;
    return ok;
  }

  // spraak, turquoise als thurkwáazùh met NL stem
  let nlVoice = null;
  function pickVoices() {
    try {
      const voices = window.speechSynthesis ? speechSynthesis.getVoices() : [];
      nlVoice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith("nl")) || null;
    } catch { nlVoice = null; }
  }
  if ("speechSynthesis" in window) {
    pickVoices();
    speechSynthesis.onvoiceschanged = pickVoices;
  }
  function spreekEenmaal(text, rate = 1.0) {
    try {
      speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      if (nlVoice) u.voice = nlVoice;
      u.lang = nlVoice?.lang || "nl-NL";
      u.rate = rate;
      u.pitch = 1.0;
      u.volume = 1.0;
      speechSynthesis.speak(u);
    } catch { /* stil falen */ }
  }
  function spreekKleur(naam) {
    const aan = document.getElementById("spreekToggle")?.checked;
    if (!aan || !("speechSynthesis" in window)) return;
    const key = String(naam || "").toLowerCase().trim();

    if (key === "turquoise") {
      // accenten sturen de klank in de NL stem
      spreekEenmaal("thurkwáazùh", 0.98);
      return;
    }
    spreekEenmaal(naam, 1.0);
  }

  // kleuren en labels
  let opties = ["zalm roze","lila","beige","wit","zilver","goud","turquoise"];
  const kleurMap = {
    "zalm roze":"#FFA07A",
    "lila":"#C8A2C8",
    "beige":"#F5F5DC",
    "wit":"#FFFFFF",
    "zilver":"#C0C0C0",
    "goud":"#D4AF37",
    "turquoise":"#40E0D0"
  };
  const metallicKleuren = new Set(["goud","zilver"]);

  // goud en zilver niet als buren
  function scheidBuren(arr, a, b) {
    const n = arr.length;
    let ia = arr.indexOf(a), ib = arr.indexOf(b);
    if (ia < 0 || ib < 0) return arr;
    const buren = (x, y) => Math.abs(x - y) === 1 || Math.abs(x - y) === n - 1;
    if (!buren(ia, ib)) return arr;
    const [item] = arr.splice(ib, 1);
    ia = arr.indexOf(a);
    const insert = (ia + 2) % arr.length;
    arr.splice(insert, 0, item);
    return arr;
  }
  opties = scheidBuren(opties, "goud", "zilver");

  const donkereSegmenten = new Set([]);
  const lijnenWitKleuren = new Set([]);
  const pupilKleuren = new Set([]);

  // spinner
  const rad = document.getElementById("rad");
  const rctx = rad.getContext("2d");
  const CX = 220, CY = 200, R = 190;
  let hoek = 0, bezig = false, gekozen = opties[0];

  // maak endhoek altijd groter of gelijk
  function normBoog(a0, a1) {
    const tau = Math.PI * 2;
    let s = a0, e = a1;
    while (e < s) e += tau;
    return [s, e];
  }

  // metallic gloed in segment, licht staat vast in het scherm
  function tekenMetallicInSegment(naam, a0, a1) {
    if (!metallicKleuren.has(naam)) return;
    const [s, e] = normBoog(a0, a1);

    rctx.save();
    rctx.beginPath();
    rctx.moveTo(CX, CY);
    rctx.arc(CX, CY, R, s, e, false);
    rctx.closePath();
    rctx.clip();

    const overlayGrad = rctx.createLinearGradient(CX, CY - R, CX, CY + R);
    if (naam === "goud") {
      overlayGrad.addColorStop(0.00, "rgba(255,250,210,0.70)");
      overlayGrad.addColorStop(0.35, "rgba(255,255,255,0.18)");
      overlayGrad.addColorStop(0.60, "rgba(0,0,0,0.36)");
      overlayGrad.addColorStop(1.00, "rgba(120,90,0,0.30)");
    } else {
      overlayGrad.addColorStop(0.00, "rgba(255,255,255,0.70)");
      overlayGrad.addColorStop(0.50, "rgba(0,0,0,0.36)");
      overlayGrad.addColorStop(1.00, "rgba(235,235,235,0.32)");
    }

    if (supportMode(rctx, "overlay")) {
      rctx.globalCompositeOperation = "overlay";
      rctx.fillStyle = overlayGrad;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);
      rctx.globalCompositeOperation = "source-over";
    } else {
      rctx.globalCompositeOperation = "multiply";
      rctx.fillStyle = overlayGrad;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);
      rctx.globalCompositeOperation = "lighter";
      rctx.fillStyle = "rgba(255,255,255,0.18)";
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);
      rctx.globalCompositeOperation = "source-over";
    }

    // glansstrepen
    rctx.save();
    rctx.translate(CX, CY);
    rctx.rotate(-Math.PI / 10);
    rctx.translate(-CX, -CY);
    rctx.globalAlpha = 0.55;
    for (let i = 0; i < 3; i++) {
      const g = rctx.createLinearGradient(CX - R, CY - R + i * R * 0.25, CX + R, CY - R + i * R * 0.25);
      g.addColorStop(0,   "rgba(255,255,255,0)");
      g.addColorStop(0.5, "rgba(255,255,255,0.95)");
      g.addColorStop(1,   "rgba(255,255,255,0)");
      rctx.fillStyle = g;
      rctx.fillRect(CX - R, CY - R + i * R * 0.25, R * 2, R * 0.12);
    }
    rctx.restore();
    rctx.globalAlpha = 1;

    // highlights
    if (supportMode(rctx, "screen")) {
      rctx.globalCompositeOperation = "screen";
      const rg = rctx.createRadialGradient(CX - R * 0.30, CY - R * 0.35, 0, CX - R * 0.30, CY - R * 0.35, R * 0.9);
      rg.addColorStop(0.00, "rgba(255,255,255,1.00)");
      rg.addColorStop(0.35, "rgba(255,255,255,0.60)");
      rg.addColorStop(1.00, "rgba(255,255,255,0.00)");
      rctx.fillStyle = rg;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);

      const rg2 = rctx.createRadialGradient(CX + R * 0.35, CY + R * 0.35, 0, CX + R * 0.35, CY + R * 0.35, R * 0.45);
      rg2.addColorStop(0.00, "rgba(255,255,255,0.85)");
      rg2.addColorStop(0.40, "rgba(255,255,255,0.35)");
      rg2.addColorStop(1.00, "rgba(255,255,255,0.00)");
      rctx.fillStyle = rg2;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);

      rctx.globalCompositeOperation = "source-over";
    } else {
      rctx.globalAlpha = 0.7;
      const rg = rctx.createRadialGradient(CX - R * 0.30, CY - R * 0.35, 0, CX - R * 0.30, CY - R * 0.35, R * 0.9);
      rg.addColorStop(0.00, "rgba(255,255,255,1.00)");
      rg.addColorStop(0.35, "rgba(255,255,255,0.60)");
      rg.addColorStop(1.00, "rgba(255,255,255,0.00)");
      rctx.fillStyle = rg;
      rctx.fillRect(CX - R, CY - R, R * 2, R * 2);
      rctx.globalAlpha = 1;
    }

    rctx.restore();
  }

  function tekenSchijven() {
    const stap = 2 * Math.PI / opties.length;
    const rot = hoek * Math.PI / 180;

    for (let i = 0; i < opties.length; i++) {
      const naam = opties[i];
      const [s, e] = normBoog(i * stap + rot, (i + 1) * stap + rot);

      rctx.beginPath();
      rctx.moveTo(CX, CY);
      rctx.arc(CX, CY, R, s, e, false);
      rctx.closePath();
      rctx.fillStyle = kleurMap[naam] || "#000";
      rctx.fill();

      tekenMetallicInSegment(naam, s, e);

      rctx.strokeStyle = "#222";
      rctx.lineWidth = 2;
      rctx.stroke();

      const mid = s + (e - s) / 2;
      const tekstkleur = donkereSegmenten.has(naam) ? "#fff" : "#000";
      rctx.save();
      rctx.translate(CX, CY);
      rctx.rotate(mid);
      rctx.textAlign = "right";
      rctx.fillStyle = tekstkleur;
      rctx.font = "16px system-ui, Arial";
      rctx.fillText(naam, R - 12, 6);
      rctx.restore();
    }

    rctx.lineWidth = 6;
    rctx.strokeStyle = "#333";
    rctx.beginPath();
    rctx.arc(CX, CY, R + 3, 0, Math.PI * 2);
    rctx.stroke();
  }

  // pijl buiten het rad, rechts, wijst naar links
  function tekenPijl() {
    const offset = 22;
    const tipX = CX + R + offset;
    const tipY = CY;
    const baseX = tipX + 34;
    const halfH = 22;

    rctx.beginPath();
    rctx.moveTo(tipX, tipY);
    rctx.lineTo(baseX, tipY - halfH);
    rctx.lineTo(baseX, tipY + halfH);
    rctx.closePath();
    rctx.fillStyle = "#222";
    rctx.fill();

    rctx.beginPath();
    rctx.arc(CX, CY, 6, 0, Math.PI * 2);
    rctx.fill();
  }

  function renderRad() {
    rctx.clearRect(0, 0, rad.width, rad.height);
    tekenSchijven();
    tekenPijl();
  }

  function indexOnderPijl() {
    const n = opties.length, stap = 360 / n;
    let a = (-hoek) % 360; if (a < 0) a += 360;
    return Math.floor(a / stap) % n;
  }

  function draai() {
    if (bezig) return;
    bezig = true;
    document.getElementById("draaiBtn").disabled = true;
    let snelheid = 20 + Math.random() * 15;
    hoek += 360 * 4;

    function anim() {
      snelheid *= 0.985;
      hoek += snelheid;
      renderRad();
      if (snelheid > 0.25) requestAnimationFrame(anim);
      else {
        hoek = hoek % 360;
        renderRad();
        const idx = indexOnderPijl();
        gekozen = opties[idx];

        const lijnenWit = lijnenWitKleuren.has(gekozen);
        const toonPupillen = pupilKleuren.has(gekozen);
        const metallicType = metallicKleuren.has(gekozen) ? gekozen : null;

        toonResultaat(gekozen);
        kleurMonster(kleurMap[gekozen], lijnenWit, toonPupillen, metallicType);

        spreekKleur(gekozen);

        bezig = false;
        document.getElementById("draaiBtn").disabled = false;
      }
    }
    requestAnimationFrame(anim);
  }

  function toonResultaat(tekst) {
    document.getElementById("resultaat").textContent = `Gekozen kleur: ${tekst}`;
    document.getElementById("live").textContent = `Kleur ${tekst}`;
  }

  // monster
  const mCanvas = document.getElementById("monster");
  const m = mCanvas.getContext("2d");
  const imgMask  = new Image();  imgMask.src  = "monster-mask.png";
  const imgLine  = new Image();  imgLine.src  = "monster-line.png";
  const imgPupil = new Image();  imgPupil.src = "monster-pupillen.png";

  let assetsGereed = false;
  Promise.all([
    new Promise(res => imgMask.onload  = res),
    new Promise(res => imgLine.onload  = res),
    new Promise(res => imgPupil.onload = res)
  ]).then(() => {
    assetsGereed = true;
    tekenMonsterKader();
    kleurMonster(kleurMap[gekozen], false, false, null);
  });

  function tekenMonsterKader() {
    m.clearRect(0, 0, mCanvas.width, mCanvas.height);
    m.save();
    m.lineWidth = 6;
    m.strokeStyle = "#222";
    m.fillStyle = "#fff";
    m.beginPath();
    rondeRechthoek(m, 12, 12, mCanvas.width - 24, mCanvas.height - 24, 18);
    m.fill();
    m.stroke();
    m.restore();
  }

  function kleurMonster(vulkleur, lijnenWit, toonPupillen, metallicType) {
    if (!assetsGereed) return;

    tekenMonsterKader();

    const pad = 24;
    const doelW = mCanvas.width - pad * 2;
    const doelH = mCanvas.height - pad * 2;
    const ratio = Math.min(doelW / imgMask.width, doelH / imgMask.height);
    const w = Math.max(1, Math.round(imgMask.width * ratio));
    const h = Math.max(1, Math.round(imgMask.height * ratio));
    const x = Math.round((mCanvas.width - w) / 2);
    const y = Math.round((mCanvas.height - h) / 2);

    m.save();
    m.fillStyle = vulkleur;
    m.fillRect(x, y, w, h);
    m.globalCompositeOperation = "destination-in";
    m.imageSmoothingEnabled = true;
    m.drawImage(imgMask, x, y, w, h);
    m.globalCompositeOperation = "source-over";

    if (metallicType) voegMetaalGlansToeMonster(metallicType, x, y, w, h);

    if (!lijnenWit) {
      m.drawImage(imgLine, x, y, w, h);
    } else {
      const off = document.createElement("canvas");
      off.width = w; off.height = h;
      const o = off.getContext("2d");
      o.fillStyle = "#ffffff";
      o.fillRect(0, 0, off.width, off.height);
      o.globalCompositeOperation = "destination-in";
      o.drawImage(imgLine, 0, 0, off.width, off.height);
      o.globalCompositeOperation = "source-over";
      m.drawImage(off, x, y);
    }

    if (toonPupillen) m.drawImage(imgPupil, x, y, w, h);
    m.restore();
  }

  function voegMetaalGlansToeMonster(type, x, y, w, h) {
    const overlay = document.createElement("canvas");
    overlay.width = w; overlay.height = h;
    const o = overlay.getContext("2d");
    const lg = o.createLinearGradient(0, 0, 0, h);
    if (type === "goud") {
      lg.addColorStop(0.00, "rgba(255,250,210,0.70)");
      lg.addColorStop(0.35, "rgba(255,255,255,0.18)");
      lg.addColorStop(0.60, "rgba(0,0,0,0.36)");
      lg.addColorStop(1.00, "rgba(120,90,0,0.30)");
    } else {
      lg.addColorStop(0.00, "rgba(255,255,255,0.70)");
      lg.addColorStop(0.50, "rgba(0,0,0,0.36)");
      lg.addColorStop(1.00, "rgba(235,235,235,0.32)");
    }
    o.fillStyle = lg;
    o.fillRect(0, 0, w, h);
    o.globalCompositeOperation = "destination-in";
    o.drawImage(imgMask, 0, 0, w, h);

    m.save();
    if (supportMode(m, "overlay")) {
      m.globalCompositeOperation = "overlay";
      m.drawImage(overlay, x, y);
      m.globalCompositeOperation = "source-over";
    } else {
      m.globalCompositeOperation = "multiply";
      m.drawImage(overlay, x, y);
      m.globalCompositeOperation = "lighter";
      m.drawImage(overlay, x, y);
      m.globalCompositeOperation = "source-over";
    }
    m.restore();

    const spec = document.createElement("canvas");
    spec.width = w; spec.height = h;
    const s = spec.getContext("2d");
    const rg = s.createRadialGradient(w * 0.30, h * 0.25, 0, w * 0.30, h * 0.25, Math.max(w, h) * 0.55);
    rg.addColorStop(0.00, "rgba(255,255,255,1.00)");
    rg.addColorStop(0.30, "rgba(255,255,255,0.60)");
    rg.addColorStop(1.00, "rgba(255,255,255,0.00)");
    s.fillStyle = rg;
    s.fillRect(0, 0, w, h);
    const rg2 = s.createRadialGradient(w * 0.70, h * 0.75, 0, w * 0.70, h * 0.75, Math.max(w, h) * 0.25);
    rg2.addColorStop(0.00, "rgba(255,255,255,0.85)");
    rg2.addColorStop(0.40, "rgba(255,255,255,0.35)");
    rg2.addColorStop(1.00, "rgba(255,255,255,0.00)");
    s.fillStyle = rg2;
    s.fillRect(0, 0, w, h);
    s.globalCompositeOperation = "destination-in";
    s.drawImage(imgMask, 0, 0, w, h);

    m.save();
    if (supportMode(m, "screen")) {
      m.globalCompositeOperation = "screen";
      m.drawImage(spec, x, y);
      m.globalCompositeOperation = "source-over";
    } else {
      m.globalAlpha = 0.6;
      m.drawImage(spec, x, y);
      m.globalAlpha = 1;
    }
    m.restore();
  }

  function rondeRechthoek(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  // init
  document.getElementById("draaiBtn").addEventListener("click", draai);
  document.addEventListener("keydown", e => {
    if ((e.key === "Enter" || e.code === "Space") && !bezig) draai();
  });
  renderRad();
  </script>
</body>
</html>
